#!/usr/bin/env python3
from ropium import *
from prompt_toolkit import PromptSession, ANSI
import os

# Colors and util functions
MAIN_COLOR_ANSI = '\033[92m'    # Default color 
ERROR_COLOR_ANSI = '\033[91m' 
BOLD_COLOR_ANSI = '\033[1m'
WARNING_COLOR_ANSI = '\033[93m'
END_COLOR_ANSI = '\033[0m'

def str_bold(msg):
    return BOLD_COLOR_ANSI + msg + END_COLOR_ANSI

def str_error(msg):
    return ERROR_COLOR_ANSI + msg + END_COLOR_ANSI

def str_main(msg):
    return MAIN_COLOR_ANSI + msg + END_COLOR_ANSI
    
def str_warning(msg):
    return WARNING_COLOR_ANSI + msg + END_COLOR_ANSI

def error(msg, skip=False):
    if skip:
        print('')
    print("\t[" + str_bold(str_error("!")) + "] " + msg)

def info(msg):
    print("\t[" + str_main("+") + "] " + msg)
    
def warning(msg, skip=False):
    if skip:
        print('')
    print("\t[" + str_bold(str_warning("!")) + "] " + msg)


compiler = None
bad_bytes = []
keep_regs = []
safe_mem = True
start_msg = "\n" + str_bold("ROPium") + " - v3.0\n"

# Commands
CMD_HELP = "help"
CMD_LOAD = "load"
CMD_FIND = "find"
CMD_BADBYTES = "badbytes"
CMD_KEEPREGS = "keepregs"
CMD_ABI = "abi"
CMD_SAFEMEM = "safemem"
CMD_EXIT = "exit"

# Arch correspondance
str_to_arch = {"X86":ARCH.X86, "X64":ARCH.X64}

# Main function
def main():
    print(start_msg)
    
    finish = False
    promptSession = PromptSession(ANSI(u"("+ str_main(u"ropium") +u")> "))
    while( not finish ):
        try:
            user_input = promptSession.prompt()
            args = user_input.split()
            argslen = len(args)
            if( argslen > 0 ):
                command = args[0]
            else:
                command = None
                continue

            if( command == CMD_LOAD ):
                try:
                    load(args[1:])
                except LoadException as e:
                    error(str(e), skip=True)
            elif( command == CMD_EXIT ):
                finish = True
            elif( command == CMD_HELP ):
                show_help()
            elif( command == CMD_FIND ):
                try:
                    find(args[1:])
                except FindException as e:
                    error(str(e), skip=True)
            elif( command == CMD_BADBYTES ):
                try:
                    badbytes(args[1:])
                except ContextException as e:
                    error(str(e), skip=True)
            elif( command == CMD_KEEPREGS ):
                try:
                    keepregs(args[1:])
                except ContextException as e:
                    error(str(e), skip=True)
            elif( command == CMD_SAFEMEM ):
                try:
                    safemem(args[1:])
                except ContextException as e:
                    error(str(e), skip=True)
            elif( command == CMD_ABI ):
                try:
                    cmd_abi(args[1:])
                except ContextException as e:
                    error(str(e), skip=True)
            else:
                error(f"Unknown command '{command}'", skip=True)
            print('')
        except KeyboardInterrupt:
            pass
        except EOFError:
            finish = True
    print('Thanks for using ROPium !')
    return

# Load command
class LoadException(Exception):
    pass

def load(args):
    global compiler
    OPTIONS_ARCH = ['-a', '--arch']
    OPTIONS_HELP = ['-h', '--help']
    seen_arch = False
    seen_filename = False
    arch = None
    filenames = []
    
    # Help string
    load_help = "DEBUG TODO HELP"
    
    # Parse arguments
    if not args:
        print(load_help)
        return
    i = 0
    while i < len(args):
        if args[i] in OPTIONS_ARCH:
            if seen_arch:
                raise LoadException(f"Option '{args[i]}' can be used only one time") 
            seen_arch = True
            if( i+1 == len(args)):
                raise LoadException(f"Missing argument after {args[i]}")
            else:
                arch = args[i+1]
            i += 2
        elif args[i] in OPTIONS_HELP:
            print(load_help)
            return
        else:
            filenames.append(args[i])
            i += 1

    # Check arguments
    if not filenames:
        raise LoadException("Missing filename")
    if not arch and not compiler:
        raise LoadException("Missing architecture")
    if arch and (arch not in str_to_arch):
        raise LoadException(f"Unsupported architecture: {arch}")

    # Instanciate compiler if not already
    if compiler is None:
        compiler = ROPium(str_to_arch[arch])
    elif arch and (str_to_arch[arch] != compiler.arch):
        raise LoadException(f"Already working on a different architecture than '{arch}'")

    print('') # So it's moar pretty
    for f in filenames:
        # Test if the file exists 
        if not os.path.isfile(f):
            warning(f"Skipped: {f} (file doesn't exist)")
        else:
            compiler.load(f)
            info(f"Loaded: {f}")


# Find command
class FindException(Exception):
    pass

def find(args):
    global compiler
    global bad_bytes
    global keep_regs
    global safemem
    global abi

    if not compiler:
        raise FindException("You must load a binary before finding ropchains")

    query = "".join(args)
    compiler.bad_bytes = bad_bytes
    compiler.keep_regs = keep_regs
    compiler.safe_mem = safe_mem
    compiler.abi = abi
    try:
        ropchain = compiler.compile(query)
    except ValueError as e:
        raise FindException(str(e))
    except RuntimeError as e:
        raise FindException(str(e))
    if ropchain:
        print('')
        print(ropchain.dump(tab="\t"))
    else:
        print("\n\tNo ROPChain found.")

# Badbytes command
class ContextException(Exception):
    pass

def badbytes(args):
    global compiler
    badbytes_help = "TODO DEBUG HELP"

    if not args:
        print(badbytes_help)
        return
    
    subcommand = args[0]
    if subcommand == "set":
        set_badbytes(args[1:])
    elif subcommand == "reset":
        reset_bad_bytes(args[1:])
    else:
        raise ContextException(f"Unsupported action '{subcommand}'")

def str_to_byte(s):
    try:
        return int(s, 10)
    except:
        try:
            return int(s, 16)
        except:
            return None

def set_badbytes(args):
    global bad_bytes
    new_bad = []
    for arg in args:
        bad = str_to_byte(arg)
        if bad is None or bad > 0xff:
            raise ContextException(f"'{arg}' is not a valid byte")
        new_bad.append(bad)
    bad_bytes = new_bad

def reset_badbytes(args):
    global bad_bytes
    bad_bytes = []


# Keppregs command
def keepregs(args):
    global compiler
    keepregs_help = "TODO DEBUG HELP"

    if not args:
        print(keepregs_help)
        return
    
    subcommand = args[0]
    if subcommand == "set":
        set_keepregs(args[1:])
    elif subcommand == "reset":
        reset_keepregs(args[1:])
    else:
        raise ContextException(f"Unsupported action '{subcommand}'")

reg_map = {
    "eax":X86.EAX,
    "ebx":X86.EBX,
    "ecx":X86.ECX,
    "edx":X86.EDX,
    "esi":X86.ESI,
    "edi":X86.EDI,
    "esp":X86.ESP,
    "ebp":X86.EBP,
    "eip":X86.EIP,
    
    "rax":X64.RAX,
    "rbx":X64.RBX,
    "rcx":X64.RBX,
    "rdx":X64.RDX,
    "rdi":X64.RDI,
    "rsi":X64.RSI,
    "rsp":X64.RSP,
    "rbp":X64.RBP,
    "rip":X64.RIP,
    "r8":X64.R8,
    "r9":X64.R9,
    "r10":X64.R10,
    "r11":X64.R11,
    "r12":X64.R12,
    "r13":X64.R13,
    "r14":X64.R14,
    "r15":X64.R15
}

def str_to_reg(s):
    if s in reg_map:
        return reg_map[s]
    else:
        return None

def set_keepregs(args):
    global keep_regs
    new_keep = []
    for arg in args:
        reg = str_to_reg(arg)
        if reg is None:
            raise ContextException(f"Register '{arg}' is not supported for 'keepregs'")
        new_keep.append(arg)
    keep_regs = new_keep

def reset_keepregs(args):
    global keep_regs
    keep_regs = []


# safemem command
def safemem(args):
    global compiler
    global safe_mem
    safemem_help = "TODO DEBUG HELP"

    if not args:
        print(safemem_help)
        return
    
    subcommand = args[0]
    if subcommand == "set":
        safe_mem = True
    elif subcommand == "unset":
        safe_mem = False
    else:
        raise ContextException(f"Unsupported action '{subcommand}'")
    
    if len(args) > 1:
        args_str = ' '.join(args[1:])
        warning(f"Extra arguments ignored: '{args_str}'", skip=True)

# ABI Command
str_to_abi = {
    "X86_CDECL":ABI.X86_CDECL
}

def cmd_abi(args):
    global compiler
    abi_help = "TODO DEBUG HELP"

    if not args:
        print(abi_help)
        return
    
    subcommand = args[0]
    if subcommand == "set":
        set_abi(args[1:])
    else:
        raise ContextException(f"Unsupported action '{subcommand}'")

def set_abi(args):
    global abi
    
    if not args:
        raise ContextException(f"Missing ABI argument")
    
    if args[0] not in str_to_abi:
        raise ContextException(f"Unsupported ABI: '{args[0]}'")
    else:
        abi = str_to_abi[args[0]]
        
    if len(args) > 1:
        extra_args = ' '.join(args[1:])
        warning(f"Extra arguments ignored: '{extra_args}'", skip=True)
    

def show_help():
    print("Not implemented")

if __name__ == "__main__":
    main()
