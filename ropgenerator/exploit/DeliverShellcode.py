# -*- coding:utf-8 -*- 
# Syscall module: building ropchains performing syscalls
from ropgenerator.core.IO import str_special, banner, str_bold, error
from ropgenerator.main.Utils import parse_function, parse_offset, parse_keep_regs, parse_bad_bytes, parse_range
from ropgenerator.core.Architecture import *
from ropgenerator.main.Load import loaded_binary
from ropgenerator.core.Gadget import set_gadgets_offset
from ropgenerator.main.Scanner import set_binary_offset, get_readwrite_memory
from ropgenerator.core.ChainingEngine import *
import ropgenerator.exploit.syscall.SyscallLinuxX64 as LinuxX64
import ropgenerator.exploit.syscall.SyscallLinuxX86 as LinuxX86
from ropgenerator.core.IO import *
import ropgenerator.exploit.Systems as Systems

#############################
# DELIVER SHELLCODE COMMAND #
#############################

OPTION_OUTPUT = '--output-format'
OPTION_OUTPUT_SHORT = '-f'
# Options for output
OUTPUT_CONSOLE = 'console'
OUTPUT_PYTHON = 'python'
OUTPUT_RAW = 'raw'
OUTPUT = None # The one choosen 

OPTION_BAD_BYTES = '--bad-bytes'
OPTION_BAD_BYTES_SHORT = '-b'

OPTION_KEEP_REGS = '--keep-regs'
OPTION_KEEP_REGS_SHORT = '-k'

OPTION_OFFSET="--offset"
OPTION_OFFSET_SHORT = "-off"

OPTION_SHORTEST = '--shortest'
OPTION_SHORTEST_SHORT = '-s'

OPTION_LMAX = '--max-length'
OPTION_LMAX_SHORT = '-m'

OPTION_HELP = "--help"
OPTION_HELP_SHORT = "-h"

OPTION_RW_MEMORY = '--rw-memory'
OPTION_RW_MEMORY_SHORT = '-rw'

CMD_DSHELL_HELP =  banner([str_bold("'(A)lloc (C)opy (E)xecute' command"),\
                    str_special("(Deliver a shellcode & Execute it)")])
CMD_DSHELL_HELP += "\n\n\t"+str_bold("Description:")+\
"\n\t\tThis method first creates an executable memory area,"+\
"\n\t\tthen copies a shellcode into this area, and finally"+\
"\n\t\tjumps to execute the shellcode"
CMD_DSHELL_HELP += "\n\n\t"+str_bold("Usage:")+\
"\n\t\tace <sys> [OPTIONS]"
CMD_DSHELL_HELP += "\n\n\t"+str_bold("Options")+":"
CMD_DSHELL_HELP += "\n\n\t\t"+str_special(OPTION_BAD_BYTES_SHORT)+","+str_special(OPTION_BAD_BYTES)+" <bytes>\t Bad bytes for payload.\n\t\t\t\t\t Expected format is a list of bytes \n\t\t\t\t\t separated by comas (e.g '-b 0A,0B,2F')"
CMD_DSHELL_HELP += "\n\n\t\t"+str_special(OPTION_KEEP_REGS_SHORT)+","+str_special(OPTION_KEEP_REGS)+" <regs>\t Registers that shouldn't be modified.\n\t\t\t\t\t Expected format is a list of registers \n\t\t\t\t\t separated by comas (e.g '-k edi,eax')"
CMD_DSHELL_HELP += "\n\n\t\t"+str_special(OPTION_OFFSET_SHORT)+","+\
    str_special(OPTION_OFFSET)+" <int>\t Offset to add to gadget addresses"   
CMD_DSHELL_HELP += "\n\n\t\t"+str_special(OPTION_RW_MEMORY_SHORT)+","+\
    str_special(OPTION_RW_MEMORY)+" <range>\t Usable read-write memory"
CMD_DSHELL_HELP += "\n\n\t\t"+str_special(OPTION_LMAX_SHORT)+","+str_special(OPTION_LMAX)+" <int>\t Max length of the ROPChain in bytes"
CMD_DSHELL_HELP += "\n\n\t\t"+str_special(OPTION_SHORTEST_SHORT)+","+str_special(OPTION_SHORTEST)+"\t\t Find the shortest matching ROP-Chains"
CMD_DSHELL_HELP += "\n\n\t\t"+str_special(OPTION_OUTPUT_SHORT)+","+\
    str_special(OPTION_OUTPUT)+\
    " <fmt> Output format for ropchains.\n\t\t\t\t\t Expected format is one of the\n\t\t\t\t\t following: "+\
    str_special(OUTPUT_CONSOLE)+','+str_special(OUTPUT_PYTHON)
    
CMD_DSHELL_HELP += "\n\n\t\t"+str_special(OPTION_HELP_SHORT)+","+str_special(OPTION_HELP)+"\t\t Show this help"
CMD_DSHELL_HELP += "\n\n\t"+str_bold("Supported systems")+": "+', '.join([str_special(s) for s in Systems.available_systems_str()])
CMD_DSHELL_HELP += "\n\n\t"+str_bold("Range format")+": "+\
    str_special("<lower_address>")+","+str_special("<higher_address>")

CMD_DSHELL_HELP += "\n\n\t"+str_bold("Examples")+": "+\
    "\n\t\tace LINUX -b 80,E2 -off 0x40178 -m 2000"+\
    "\n\t\tace LINUX -rw 0x30000,0x30100 -f python -s"

def print_help():
    print(CMD_DSHELL_HELP)

def deliver_shellcode(args):
    global OUTPUT, OUTPUT_CONSOLE, OUTPUT_PYTHON

    if( not args):
        print_help()
        return
    OUTPUT = OUTPUT_CONSOLE
    offset = 0
    i = 0
    seenOutput = False
    seenBadBytes = False
    seenKeepRegs = False
    seenShortest = False
    seenLmax = False
    seenOffset = False
    seenRw = False
    bad_bytes = []
    keep_regs = []
    lmax = get_default_lmax()*6 # 6 is an arbitrary value here
    lower_valid_write_addr = 0
    higher_valid_write_addr = 0
    
    # Parsing arguments
    # First argument must be the target OS
    if( len(args) == 0 ):
        error("Missing arguments")
        return
    system = Systems.str_to_target_system(args[0])
    if( system is None):
        error("Unsupported system '"+args[0]+"'")
        print(str_bold("\tSupported systems")+": "+', '.join([str_special(s) for s in Systems.available_systems_str()]))
        return
    # Then parse the options  
    args = args[1:]
    while i < len(args):
        arg = args[i]
        if( args[i] in [OPTION_BAD_BYTES, OPTION_BAD_BYTES_SHORT]):
            if( seenBadBytes ):
                error( "'" + arg + "' option should be used only once.")
                return 
            if( i+1 >= len(args)):
                error("Missing bad bytes after option '"+arg+"'")
                return 
            seenBadBytes = True
            (success, bad_bytes) = parse_bad_bytes(args[i+1])
            if( not success ):
                error(bad_bytes)
                return
            i = i+1
        elif( args[i] in [OPTION_KEEP_REGS, OPTION_KEEP_REGS_SHORT]):
            if( seenKeepRegs ):
                error( "'" + arg + "' option should be used only once.")
                return 
            if( i+1 >= len(args)):
                error("Missing registers after option '"+arg+"'")
                return 
            seenKeepRegs = True
            (success, keep_regs) = parse_keep_regs(args[i+1])
            if( not success ):
                error(keep_regs)
                return
            i = i+1
        elif( args[i] == OPTION_OFFSET or args[i] == OPTION_OFFSET_SHORT ):
            if( seenOffset ):
                error("'" + arg + "' option should be used only once.")
                return 
            if( i+1 >= len(args)):
                error("Missing output format after option '"+arg+"'")
                return
            (success, offset) = parse_offset(args[i+1])
            if( not success ):
                error(offset)
                return
            i = i+1
            seenOffset = True
        elif( args[i] in [OPTION_RW_MEMORY, OPTION_RW_MEMORY_SHORT]):
            if( seenRw ):
                error( "'" + arg + "' option should be used only once.")
                return 
            if( i+1 >= len(args)):
                error("Missing address range after option '"+arg+"'")
                return 
            seenRw = True
            (success, addr_range) = parse_range(args[i+1])
            if( not success ):
                error(addr_range)
                return
            (lower_valid_write_addr, higher_valid_write_addr) = addr_range
            i = i+1
        elif( args[i] in [OPTION_SHORTEST, OPTION_SHORTEST_SHORT]):
            if( seenShortest ):
                error("'" + arg + "' option should be used only once.")
                return 
            seenShortest = True
        elif( args[i] == OPTION_LMAX or args[i] == OPTION_LMAX_SHORT ):
            if( seenLmax ):
                error("'" + arg + "' option should be used only once.")
                return 
            if( i+1 >= len(args)):
                error("Missing length after option '"+arg+"'")
                return 
            (success, lmax) = parse_lmax(args[i+1])
            if( not success ):
                error(lmax)
                return 
            i = i +1 
            seenLmax = True
        elif( args[i] in [OPTION_OUTPUT, OPTION_OUTPUT_SHORT]):
            if( seenOutput ):
                error("'" + arg + "' option should be used only once.")
                return 
            if( i+1 >= len(args)):
                error("Missing output format after option '"+arg+"'")
                return 
            if( args[i+1] in [OUTPUT_CONSOLE, OUTPUT_PYTHON]):
                OUTPUT = args[i+1]
                seenOutput = True
                i = i +1
            else:
                error("'" + args[i+1] + "' output format is not supported")
                return  
        elif( args[i] in [OPTION_HELP, OPTION_HELP_SHORT]):
            print_help()
            return 
        else:
            error("Error. Unknown option '{}'".format(args[i]))
            return 
        i += 1

    # Build the exploit !!! 
    # Check if the user loaded some binaries 
    if( not loaded_binary() ):
        error("You should load a binary before building ROPChains")
        return 
    # Check for valid writable memory to copy strings
    if( lower_valid_write_addr == 0 ):
        (lower_valid_write_addr,higher_valid_write_addr) = get_readwrite_memory() 
    # Set offset 
    set_gadgets_offset(offset)
    set_binary_offset(offset)
    # Build the ropchain
    params = SearchParametersBinding(keep_regs, bad_bytes, lmax, seenShortest, lower_valid_write_addr=lower_valid_write_addr, higher_valid_write_addr=higher_valid_write_addr)
    if( system == Systems.TargetSystem.Linux ):
        res = deliver_shellcode_build_linux(params)
    else:
        error("Not yet supported for this system :'(")
        return 
    # Print result 
    if( res is None ):
        error("No matching ROPChain found")
    elif( isinstance(res, str) ):
        error(res)
        return 
    else:
        if( OUTPUT == OUTPUT_CONSOLE ):
            print(res.to_str_console(curr_arch_octets(), bad_bytes ))
        elif( OUTPUT == OUTPUT_PYTHON ):
            print(res.to_str_python(curr_arch_octets(), bad_bytes, True, False ))
    
    # Reset offset 
    set_gadgets_offset(0)
    set_binary_offset(0)

def deliver_shellcode_build_linux(params):
    return None
    
def deliver_shellcode_build_windows(params):
    return None
