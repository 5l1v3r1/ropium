# -*- coding:utf-8 -*- 
# Utils module: useful functions to build exploits
from ropgenerator.semantic.Engine import search, LMAX
from ropgenerator.Constraints import Constraint, RegsNotModified, Assertion, Chainable, StackPointerIncrement
from ropgenerator.semantic.ROPChains import ROPChain
from ropgenerator.Database import QueryType, DBAllPossibleWrites
from ropgenerator.exploit.Scanner import getFunctionAddress, findBytes
from ropgenerator.IO import verbose, string_bold, string_special, string_ropg
import itertools
import ropgenerator.Architecture as Arch 

#### Pop values into registers 

POP_MULTIPLE_LMAX = 6000

def popMultiple(args, constraint=None, assertion=None, clmax=None, optimizeLen=False):
    """
    args is a list of pairs (reg, value) 
        OR a list of triples (reg, value, comment)
    reg is a reg UID
    value is an int
    Creates a chain that pops values into regs
    """
    if( clmax is None ):
        clmax = POP_MULTIPLE_LMAX
    elif( clmax <= 0 ):
        return None
    
    if( constraint is None ):
        constr = Constraint()
    else:
        constr = constraint
    if( assertion is None ):
        a = Assertion()
    else:
        a = assertion
        
    perms = itertools.permutations(args)
    for perm in perms:
        clmax_tmp = clmax 
        res = ROPChain()
        constr_tmp = constr
        for arg in perm:
            if( len(arg) == 3 ):
                comment = arg[2]
            else:
                comment = None
            if( optimizeLen ):
                pop = search(QueryType.CSTtoREG, arg[0], arg[1], constr_tmp, a, n=1, clmax=clmax_tmp, CSTtoREG_comment=comment, optimizeLen=True)
            else:
                pop = search(QueryType.CSTtoREG, arg[0], arg[1], constr_tmp, a, n=1, clmax=clmax_tmp, CSTtoREG_comment=comment)
            if( not pop ):
                break
            else:
                clmax_tmp -= len(pop[0])
                # If Reached max length, exit  
                if( clmax_tmp < 0 ):
                    pop = None
                    break
                else:
                    res.addChain(pop[0])
                    constr_tmp = constr_tmp.add(RegsNotModified([arg[0]]))
        if( pop ):
            return res
    return None


STORE_CONSTANT_ADDRESS_LMAX = 1000
def store_constant_address(qtype, cst_addr, value, constraint=None, assertion=None, clmax=None, optimizeLen=False):
    """
    Does a XXXtoMEM kind of query BUT the memory address is 
    a simple constant ! 
    
    Expected qtypes are only XXXtoMEM
    cst_addr is the store address
    value is the value to store, a single cst or a couple (reg,cst)
    """
    
    if( clmax is None ):
        clmax = STORE_CONSTANT_ADDRESS_LMAX
    elif( clmax <= 0 ):
        return None
    
    if( constraint is None ):
        constr = Constraint()
    else:
        constr = constraint
    if( assertion is None ):
        a = Assertion()
    else:
        a = assertion
    
    # Tranform the query type
    if( qtype == QueryType.CSTtoMEM ):
        qtype2 = QueryType.CSTtoREG 
    elif( qtype == QueryType.REGtoMEM):
        qtype2 = QueryType.REGtoREG
    elif(qtype == QueryType.MEMtoREG):
        qtype2 = QueryType.MEMtoREG
    else:
        raise Exception("Query type {} should not appear in this function!".format(qtype))
        
    tried_values = []
    tried_cst_addr = []
    best = None # If optimizeLen 
    
    for ((addr_reg, addr_cst), (reg,cst), gadget) in DBAllPossibleWrites(constr, a):
        # adapt value
        if(isinstance(value, int) ):
            adjusted_value = value - cst
        else:
            adjusted_valued = (value[0], value[1]-cst)
        adjusted_cst_addr = cst_addr - addr_cst
        if( (reg,cst) in tried_values ):
            break 
        elif( (addr_reg, addr_cst) in tried_cst_addr):
            break
        ### Try to do reg first then addr_reg 
        # Try to put the value into reg
        value_to_reg = search(qtype2, reg, adjusted_value, constr, a, clmax=clmax, n=1, optimizeLen=optimizeLen )
        if( not value_to_reg ):
            tried_values.append((reg,cst))
            break
        # Try to put the cst_addr in addr_reg
        addr_to_reg = search(qtype2, addr_reg, adjusted_cst_addr, constr.add(RegNotModified(reg)), a, clmax=clmax, n=1, optimizeLen=optimizeLen)
        if( addr_to_reg ):
            # If we found a solution 
            # Combine them and return 
            # Padd the gadget 
            res = value_to_reg[0].addChain(addr_to_reg[0]).addGadget(gadget)
            if( gadget.spInc > 0 ):
                padding_value = constr.getValidPadding(Arch.octets())
                res = res.addPadding(padding_value, n=(spInc/Arch.octets())-1)
            if( optimizeLen ):
                if( best ):
                    best = max(best,res, key=lambda x:len(x))
                else:
                    best = res
            else:
                return res

        ### Try to do addr_reg first and then reg 
        # Try to put the cst_addr in addr_reg
        addr_to_reg = search(qtype2, addr_reg, adjusted_cst_addr, constr, a, clmax=clmax, n=1, optimizeLen=optimizeLen)
        if( not addr_to_reg ):
            tried_cst_addr.append((addr_reg, addr_cst))
            break
        # Try to put the value into reg
        value_to_reg = search(qtype2, reg, adjusted_value, constr.add(RegNotModified(addr_reg)), a, clmax=clmax, n=1, optimizeLen=optimizeLen )
        if( value_to_reg ):
            # If we found a solution 
            # Combine them and return 
            # Padd the gadget 
            res = addr_to_reg[0].addChain(value_to_reg[0]).addGadget(gadget)
            if( gadget.spInc > 0 ):
                padding_value = constr.getValidPadding(Arch.octets())
                res = res.addPadding(padding_value, n=(spInc/Arch.octets())-1)
            if( optimizeLen ):
                if( best ):
                    best = max(best,res, key=lambda x:len(x))
                else:
                    best = res
            else:
                return res
    return best 
