# -*- coding:utf-8 -*- 
# Utils module: useful functions to build exploits
from ropgenerator.semantic.Engine import search, LMAX
from ropgenerator.Constraints import Constraint, RegsNotModified, Assertion, Chainable, StackPointerIncrement
from ropgenerator.semantic.ROPChains import ROPChain
from ropgenerator.Database import QueryType, DBAllPossibleWrites
from ropgenerator.exploit.Scanner import getFunctionAddress, findBytes
from ropgenerator.IO import verbose, string_bold, string_special, string_ropg
import itertools
import ropgenerator.Architecture as Arch 

#### Pop values into registers 

POP_MULTIPLE_LMAX_PER_REG = 80

def popMultiple(args, constraint=None, assertion=None, clmax=None, optimizeLen=False):
    """
    args is a list of pairs (reg, value) 
        OR a list of triples (reg, value, comment)
    reg is a reg UID
    value is an int
    Creates a chain that pops values into regs
    """
    if( clmax is None ):
        clmax = POP_MULTIPLE_LMAX_PER_REG*len(args)
    elif( clmax <= 0 ):
        return None
    
    if( constraint is None ):
        constr = Constraint()
    else:
        constr = constraint
    if( assertion is None ):
        a = Assertion()
    else:
        a = assertion
        
    perms = itertools.permutations(args)
    for perm in perms:
        clmax_tmp = clmax 
        res = ROPChain()
        constr_tmp = constr
        for arg in perm:
            if( len(arg) == 3 ):
                comment = arg[2]
            else:
                comment = None
            if( optimizeLen ):
                pop = search(QueryType.CSTtoREG, arg[0], arg[1], constr_tmp, a, n=1, clmax=clmax_tmp, CSTtoREG_comment=comment, optimizeLen=True)
            else:
                pop = search(QueryType.CSTtoREG, arg[0], arg[1], constr_tmp, a, n=1, clmax=clmax_tmp, CSTtoREG_comment=comment)
            if( not pop ):
                break
            else:
                clmax_tmp -= len(pop[0])
                # If Reached max length, exit  
                if( clmax_tmp < 0 ):
                    pop = None
                    break
                else:
                    res.addChain(pop[0])
                    constr_tmp = constr_tmp.add(RegsNotModified([arg[0]]))
        if( pop ):
            return res
    return None


STORE_CONSTANT_ADDRESS_LMAX = 80
def store_constant_address(qtype, cst_addr, value, constraint=None, assertion=None, clmax=None, optimizeLen=False):
    """
    Does a XXXtoMEM kind of query BUT the memory address is 
    a simple constant ! 
    
    Expected qtypes are only XXXtoMEM
    cst_addr is the store address
    value is the value to store, a single cst or a couple (reg,cst)
    """
    
    if( clmax is None ):
        clmax = STORE_CONSTANT_ADDRESS_LMAX
    elif( clmax <= 0 ):
        return None
    
    if( constraint is None ):
        constr = Constraint()
    else:
        constr = constraint
    if( assertion is None ):
        a = Assertion()
    else:
        a = assertion
    
    # Tranform the query type
    if( qtype == QueryType.CSTtoMEM ):
        qtype2 = QueryType.CSTtoREG 
    elif( qtype == QueryType.REGtoMEM):
        qtype2 = QueryType.REGtoREG
    elif(qtype == QueryType.MEMtoREG):
        qtype2 = QueryType.MEMtoREG
    else:
        raise Exception("Query type {} should not appear in this function!".format(qtype))
        
    tried_values = []
    tried_cst_addr = []
    best = None # If optimizeLen
    shortest = clmax # Shortest ROPChain found if optimizeLen ;) 
    
    for ((addr_reg, addr_cst), (reg,cst), gadget) in \
    sorted(DBAllPossibleWrites(constr.add(Chainable(ret=True)), a), \
    key=lambda x: 0 if (x[1] == value) else 1) :
        # DOn't use rip or rsp... 
        if( reg == Arch.ipNum() or reg == Arch.spNum()\
            or addr_reg == Arch.ipNum() or addr_reg == Arch.spNum()):
            continue
        res = None
        # Check if directly the registers we want to write ;) 
        value_is_reg = False
        value_to_reg = []
        addr_to_reg = []
        if( (reg,cst) == value ):
            value_to_reg = [ROPChain()]
            value_is_reg = True
        
        # adapt value
        if(not isinstance(value, tuple) ):
            adjusted_value = value - cst
        else:
            adjusted_value = (value[0], value[1]-cst)
        adjusted_cst_addr = cst_addr - addr_cst
        # Get spInc
        gadget_paddingLen = (gadget.spInc/Arch.octets())-1
        # Check if tried before 
        if( (reg,cst) in tried_values ):
            continue
        elif( (addr_reg, addr_cst) in tried_cst_addr):
            continue
        ### Try to do reg first then addr_reg 
        # Try to put the value into reg
        clmax2 = shortest - gadget_paddingLen - 1
        if( not value_is_reg):
            value_to_reg = search(qtype2, reg, adjusted_value, constr, a, clmax=clmax2, n=1, optimizeLen=optimizeLen )
            if( not value_to_reg ):
                tried_values.append((reg,cst))
                continue
            else:
                clmax2 = clmax2 - len(value_to_reg[0])
        # Try to put the cst_addr in addr_reg
        addr_to_reg = search(QueryType.CSTtoREG, addr_reg, adjusted_cst_addr, constr.add(RegsNotModified([reg])), a, clmax=clmax2, n=1, optimizeLen=optimizeLen)
        if( addr_to_reg ):
            # If we found a solution 
            # Combine them and return 
            # Padd the gadget 
            res = value_to_reg[0].addChain(addr_to_reg[0]).addGadget(gadget)
            if( gadget.spInc > 0 ):
                padding_value = constr.getValidPadding(Arch.octets())
                res = res.addPadding(padding_value, n=(gadget.spInc/Arch.octets())-1)
            if( optimizeLen ):
                if( best ):
                    best = min(best,res)
                else:
                    best = res
                shortest = len(best)
            else:
                return res

        ### Try to do addr_reg first and then reg 
        clmax2 = shortest - gadget_paddingLen - 1 
        # Try to put the cst_addr in addr_reg
        addr_to_reg = search(QueryType.CSTtoREG, addr_reg, adjusted_cst_addr, constr, a, clmax=clmax2, n=1, optimizeLen=optimizeLen)
        if( not addr_to_reg ):
            tried_cst_addr.append((addr_reg, addr_cst))
            continue
        else:
            clmax2 = clmax2 - len(addr_to_reg[0])
        # Try to put the value into reg
        if( not value_is_reg ):
            value_to_reg = search(qtype2, reg, adjusted_value, constr.add(RegsNotModified([addr_reg])), a, clmax=clmax2, n=1, optimizeLen=optimizeLen )
        if( value_to_reg ):
            # If we found a solution 
            # Combine them and return 
            # Padd the gadget 
            res = addr_to_reg[0].addChain(value_to_reg[0]).addGadget(gadget)
            if( gadget.spInc > 0 ):
                padding_value = constr.getValidPadding(Arch.octets())
                res = res.addPadding(padding_value, n=(gadget.spInc/Arch.octets())-1)
            if( optimizeLen ):
                if( best ):
                    best = min(best,res)
                else:
                    best = res
                shortest = len(best)
            else:
                return res
        
        # 5 = two pops for addr_reg and reg + 1 for the write gadget 
        # So since 5 is the shortest possible with two pops we can return 
        # We can have < 5 if reg is already equal to 'value' argument
        # But we try this case first (see sorted()) when getting possibleWrites ;) 
        if( ((not optimizeLen) or (not value_is_reg)) and (not best is None) and len(best) <= 5 ):
            return best
        elif( optimizeLen and (not best is None) and len(best) <= 3 ):
            return best
    return best 
