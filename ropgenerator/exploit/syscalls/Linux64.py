# -*- coding:utf-8 -*- 
# Linux32 module: build syscalls for linux 32 bits 

from ropgenerator.exploit.syscalls.SyscallDef import Syscall
from ropgenerator.exploit.Utils import pop_multiple
from ropgenerator.Architecture import n2r
from ropgenerator.IO import verbose
from ropgenerator.semantic.Engine import search
from ropgenerator.Database import QueryType
from ropgenerator.Constraints import Constraint, Assertion

# mprotect   
def mprotect(addr, size, prot=7, constraint=None, assertion=None):
    """
    Call mprotect from X86-64 arch
    Args must be on registers (rdi, rsi, rdx):
    Sizes are (unsigned long, size_t, unsigned long)
    rax must be 10 
    """
    
    if( constraint is None ):
        constraint = Constraint()
    if( assertion is None ):
        assertion = Assertion()
    
    # Set the registers
    args = [[n2r('rdi'),addr],[n2r('rsi'), size],[n2r('rdx'),prot], [n2r('rax'),10]]
    perms = permutations(args)
    chain = popMultiple(perm, constraint)
    if( not chain ):
        verbose("Failed to set registers for the mprotect syscall")
        return []
    # Syscall 
    syscalls = search(QueryType.SYSCALL, None, None, constraint, assertion)
    if( not syscalls ):
        verbose("Failed to find a syscall gadget")
        return []
    else:
        chain.addChain(syscalls[0])
    verbose("Success")
    return chain

mprotect =   Syscall('int', 'mprotect', \
    [('void*', 'addr'),('size_t','len'),('int','prot')], build_mprotect)


## All available syscalls 
available = dict()
available[mprotect.name] = mprotect
