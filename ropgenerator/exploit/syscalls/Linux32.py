# -*- coding:utf-8 -*- 
# Linux32 module: build syscalls for linux 32 bits 

from ropgenerator.exploit.syscalls.SyscallDef import Syscall
from ropgenerator.exploit.Utils import popMultiple
from ropgenerator.Architecture import n2r
from ropgenerator.IO import verbose, string_bold, string_ropg, string_payload
from ropgenerator.semantic.Engine import search
from ropgenerator.Database import QueryType
from ropgenerator.Constraints import Constraint, Assertion

# mprotect   
def build_mprotect(addr, size, prot=7, constraint=None, assertion = None):
    """
    Call mprotect from X86 arch
    Args must be on the stack:
    int mprotect(void *addr, size_t len, int prot)
    args must be in registers (ebx, ecx, edx)
    eax must be 0x7d = 125
    """
    
    if( constraint is None ):
        constraint = Constraint()
    if( assertion is None ):
        assertion = Assertion()
    
    # Set the registers
    args = [[n2r('eax'),0x7d],[n2r('ebx'), addr],[n2r('ecx'),size], [n2r('edx'),prot]]
    perms = permutations(args)
    chain = popMultiple(perm, constraint, assertion)
    if( not chain ):
        verbose("Failed to set registers for the mprotect syscall")
        return []
    # Int 0x80
    int80_gadgets = search(QueryType.INT80, None, None, constraint, assertion)
    if( not int80_gadgets ):
        verbose("Failed to find an 'int 80' gadget")
        return []
    else:
        chain.addChain(int80_gadgets[0])
    verbose("Success")
    return chain

mprotect =   Syscall('int', 'mprotect', \
    [('void*', 'addr'),('size_t','len'),('int','prot')], build_mprotect)


## All available syscalls 
available = dict()
available[mprotect.name+"32"] = mprotect


####################
# Useful functions #
####################
def print_available():
    global available
    print(string_bold("\n\n\tSupported Linux 32-bits syscalls"))
    for name,syscall in available.iteritems():
        print("\n\t"+string_payload(name)+":  "+str(syscall))

