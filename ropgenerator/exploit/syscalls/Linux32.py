# -*- coding:utf-8 -*- 
# Linux32 module: build syscalls for linux 32 bits 

from ropgenerator.exploit.syscalls.SyscallDef import Syscall, ArgType
from ropgenerator.exploit.HighLevelUtils import popMultiple, build_call
from ropgenerator.IO import verbose, string_bold, string_ropg, string_payload, error
from ropgenerator.semantic.Engine import search
from ropgenerator.Database import QueryType
from ropgenerator.Constraints import Constraint, Assertion
import ropgenerator.Architecture as Arch


mprotect =   Syscall('int', 'mprotect', \
    [('void*', 'addr'),('size_t','len'),('int','prot')], [ArgType.INT, ArgType.INT, ArgType.INT],\
    ['ebx', 'ecx', 'edx'], [('eax', 0x7d)])

execve = Syscall('int', 'execve', \
    [('char*', 'cmd'),('char**','argv'),('char**', 'envp')], [ArgType.STRING, ArgType.INT,ArgType.INT],\
    ['ebx','ecx','edx'], [('eax', 11)] )



## All available syscalls 
available = dict()
available[mprotect.name()] = mprotect
available[execve.name()] = execve

def supported(syscall_name):
    return (syscall_name in available)

def getSyscall(syscall_name):
    return available[syscall_name]
    
####################
# Useful functions #
####################
def print_available():
    global available
    print(string_bold("\n\n\tSupported Linux 32-bits syscalls"))
    for name,syscall in available.iteritems():
        print("\n\t"+string_payload(name)+":  "+str(syscall))

