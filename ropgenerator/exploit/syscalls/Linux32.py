# -*- coding:utf-8 -*- 
# Linux32 module: build syscalls for linux 32 bits 

from ropgenerator.exploit.syscalls.SyscallDef import Syscall
from ropgenerator.exploit.Utils import popMultiple
from ropgenerator.IO import verbose, string_bold, string_ropg, string_payload, error
from ropgenerator.semantic.Engine import search
from ropgenerator.Database import QueryType
from ropgenerator.Constraints import Constraint, Assertion
import ropgenerator.Architecture as Arch

SYSCALL_LMAX = 500

# mprotect   
def build_mprotect32(addr, size, prot=7, constraint=None, assertion = None, clmax=SYSCALL_LMAX, optimizeLen=False):
    """
    Call mprotect from X86 arch
    Args must be on the stack:
    int mprotect(void *addr, size_t len, int prot)
    args must be in registers (ebx, ecx, edx)
    eax must be 0x7d = 125
    """
    # Check args
    if not isinstance(addr, int):
        error("Argument error. Expected integer, got " + str(type(addr)))
        return None
    elif not isinstance(size, int):
        error("Argument error. Expected integer, got " + str(type(size)))
        return None
    elif not isinstance(prot, int):
        error("Argument error. Expected integer, got " + str(type(prot)))
        return None
        
    if( constraint is None ):
        constraint = Constraint()
    if( assertion is None ):
        assertion = Assertion()
    
    # Check if we have the function ! 
    verbose("Trying to call mprotect() function directly")
    func_call = build_call('mprotect', [addr, size, prot], constraint, assertion, clmax=clmax, optimizeLen=optimizeLen)
    if( not isinstance(func_call, str) ):
        verbose("Success")
        return func_call
    else:
        verbose("Coudn't call mprotect(), try direct syscall")
    
    # Otherwise do syscall directly
    # Set the registers
    args = [[Arch.n2r('eax'),0x7d],[Arch.n2r('ebx'), addr],[Arch.n2r('ecx'),size], [Arch.n2r('edx'),prot]]
    chain = popMultiple(args, constraint, assertion, clmax-1, optimizeLen)
    if( not chain ):
        verbose("Failed to set registers for the mprotect syscall")
        return None
    # Int 0x80
    int80_gadgets = search(QueryType.INT80, None, None, constraint, assertion)
    if( not int80_gadgets ):
        verbose("Failed to find an 'int 80' gadget")
        return None
    else:
        chain.addChain(int80_gadgets[0])
    verbose("Success")
    return chain

mprotect =   Syscall('int', 'mprotect', \
    [('void*', 'addr'),('size_t','len'),('int','prot')], build_mprotect32)


## All available syscalls 
available = dict()
available[mprotect.name+"32"] = mprotect


####################
# Useful functions #
####################
def print_available():
    global available
    print(string_bold("\n\n\tSupported Linux 32-bits syscalls"))
    for name,syscall in available.iteritems():
        print("\n\t"+string_payload(name)+":  "+str(syscall))

