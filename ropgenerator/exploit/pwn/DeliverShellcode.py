# -*- coding:utf-8 -*-  
# DeliverShellcode module: exploit type: copy shellcode into memory then execute it

from ropgenerator.IO import string_bold, string_special, banner, error, notify, info, verbose
from ropgenerator.Constraints import Constraint, Assertion, BadBytes
from ropgenerator.exploit.Utils import STRtoMEM
from ropgenerator.exploit.syscalls.Linux32 import build_mprotect32
from ropgenerator.exploit.syscalls.Linux64 import build_mprotect64
from ropgenerator.exploit.Scanner import getSectionAddress
from ropgenerator.exploit.Shellcode import select_shellcode
from ropgenerator.semantic.Engine import search, search_optimize_len
from ropgenerator.Database import QueryType
from ropgenerator.semantic.ROPChains import PwnChain
import ropgenerator.Architecture as Arch 

################################
#  DELIVER-SHELLCODE COMMAND   # 
################################

CMD_DSHELL_HELP =  banner([string_bold("'deliver-shellcode' command"),\
                    string_special("(Deliver a shellcode & Execute it)")])
CMD_DSHELL_HELP += "\n\n\t"+string_bold("Description:")+\
"\n\t\tThis method tries to create an executable memory area"+\
"\n\t\t, then copy a given shellcode into this area, and then"+\
"\n\t\t jump to execute this shellcode"

OPTION_ADDRESS = '-a'
OPTION_ADDRESS_SHORT = "--address"


CMD_DSHELL_HELP += "\n\n\t"+string_bold("Options")+":"
CMD_DSHELL_HELP += "\n\n\t\t"+string_special(OPTION_ADDRESS_SHORT)+","+string_special(OPTION_ADDRESS)+" <int>\t Address where to deliver shellcode"

CMD_DSHELL_HELP += "\n\n\t"+string_bold("Examples")+": "+\
    "\n\t\tNo examples yet"
    
def print_help():
    print(CMD_DSHELL_HELP)
    

def dshell(args, constraint, assertion, lmax):
            
    address = None
    seenAddress = False
    
    # Parse options    
    i = 0 
    while i < len(args):
        if( args[i][0] == '-' ):
            if( args[i] in [OPTION_ADDRESS_SHORT, OPTION_ADDRESS]):
                if( seenAddress ):
                    error("Error. '" + args[i] + "' option should be used only once")
                    return None 
                if( i+1 >= len(args)):
                    error("Error. Missing address after option '"+args[i]+"'")
                    return 
                seenAddress = True
                try:
                    address = int(args[i+1])
                except:
                    try:
                        address = int(args[i+1], 16)
                    except:
                        error("Error. '" + args[i+1] +"' bytes is not valid")
                        return None 
                i = i +1 
                seenAddress = True
            elif( args[i] in [OPTION_HELP, OPTION_HELP_SHORT]):
                        print_help()
                        return None 
        else:
            error("Error. Unknown option '{}'".format(args[i]))
            return None 
    
    # Select shellcode to deliver 
    (shellcode,shellcode_info) = select_shellcode(Arch.currentArch.name)
    if( not shellcode ):
        return None
    else:
        shellcode = str(shellcode)        
    
    # Build the exploit 
    print("")
    info("Building exploit: deliver-shellcode strategy\n\n")
    res = build_dshell(shellcode, constraint, assertion, address, lmax)
    return res
    

def build_dshell(shellcode, constraint, assertion, address, lmax ):
    """
    Returns a PwnChain() instance or None
    """
    # Build exploit
    #################
    
    res = PwnChain()
    
    #Find address for the payload 
    if( not address ):
        # Get the .bss address 
        # TODO 
        notify("Getting delivery address for shellcode")
        address = getSectionAddress('.bss')
        addr_str = ".bss" 
        if( not address ):
            verbose("Couldn't find .bss address")
            return []
    else:
        addr_str = format(address, '0'+str(Arch.octets()*2)+'x')
      
    # Deliver shellcode 
    notify("Building chain to copy shellcode in memory")
    verbose("{}/{} bytes available".format(lmax*Arch.octets(),lmax*Arch.octets()))
    STRtoMEM_chain = STRtoMEM(shellcode, address, constraint, assertion, lmax, addr_str=addr_str, hex_info=True, optimizeLen=True)
    if( not STRtoMEM_chain ):
        verbose("Could not copy shellcode into memory")
        return None
    verbose("Done")
    
    # Building mprotect 
    notify("Building mprotect() chain")
    length = len(shellcode)+1
    flag = 7 
    lmax2 = lmax-len(STRtoMEM_chain)
    verbose("{}/{} bytes available".format(lmax2*Arch.octets(),lmax*Arch.octets()))
    if( lmax2 <= 0 ):
        return None
    if( Arch.currentArch == Arch.ArchX86 ):
        mprotect_chain = build_mprotect32(address, length, flag, constraint, assertion, clmax=lmax2-2, optimizeLen=True)
    elif( Arch.currentArch == Arch.ArchX64 ):
        mprotect_chain = build_mprotect64(address, length, flag, constraint, assertion, clmax=lmax2-2, optimizeLen=True)
    else:
        mprotect_chain = None 
        verbose("mprotect call not supported for architecture {}".format(Arch.currentArch.name))
        return None
    if(not mprotect_chain):
        return None
    verbose("Done")
    
    # Jump to shellcode 
    notify("Searching chain to jump to shellcode") 
    verbose("{}/{} bytes available".format((lmax2-len(mprotect_chain))*Arch.octets(),lmax*Arch.octets())) 
    jmp_shellcode_chains = search_optimize_len(QueryType.CSTtoREG, Arch.ipNum(), address, constraint, assertion, clmax=lmax-len(STRtoMEM_chain)-len(mprotect_chain))
    if( not jmp_shellcode_chains ):
        verbose("Couldn't find a jump to the shellcode")
        return None
    verbose("Done")
    notify("Done")
    
    # Build PwnChain res and return 
    res.add(mprotect_chain, "Call mprotect({},{},{})".format(hex(address), length, flag))
    res.add(STRtoMEM_chain, "Copy shellcode to {}".format(addr_str)) 
    res.add(jmp_shellcode_chains[0], "Jump to shellcode (address {})".format(hex(address)))
    return res 
