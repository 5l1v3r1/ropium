# -*- coding:utf-8 -*- 
# Utils module: useful functions to build exploits
import itertools
from ropgenerator.core.Architecture import *
from ropgenerator.main.Scanner import get_function_address, verify_bad_bytes
from ropgenerator.core.IO import *
from ropgenerator.core.ROPChain import ROPChain
from ropgenerator.core.ChainingEngine import *
import ropgenerator.exploit.Systems as Systems 
from ropgenerator.core.Expression import Binop

# Set multiple registers to given values
def set_multiple_regs(args, params):
    """
    Creates a chain that sets multiple values into regs
    
    args is a list of pairs (reg, val) 
        OR a list of triples (reg, val, Comment) 
        
    params is a SearchParametersBinding

    """
    saved_lmax = params.lmax
    saved_keep_regs = params.keep_regs
    
    # Try all possible permutations
    perms = itertools.permutations(args)
    for perm in perms:
        params.lmax = saved_lmax
        params.keep_regs = saved_keep_regs
        res = ROPChain()
        for arg in perm:
            tmp_res = None
            if( len(arg) == 3 ):
                comment = arg[2]
            else:
                comment = None
            if( isinstance(arg[1], int)):
                # Create search arguments
                dest = DestArg(DestType.REG, arg[0])
                assign = AssignArg(AssignType.CST, arg[1])
                tmp_res = search(dest, assign, params)
            elif( isinstance(arg[1], str)):
                error("Error debug, string arguments not supported yet")
                return None
            else:
                raise Exception("Unknown argument type in popMultiple: '{}'".format(type(arg)))
                
            if( not tmp_res.found ):
                # DEBUG TODO Check fail record
                res = None
                break
            else:
                params.lmax -= tmp_res.chain.len()
                # If Reached max length, exit  
                if( params.lmax < 0 ):
                    res = None
                    break
                else:
                    res.add_chain(tmp_res.chain)
                    params.keep_regs.append(arg[0])
        if( res ):
            return res
            
    return None
    
    
## -------------------------------------------------------------
## Call functions
## ------------------------------------------------------------- 
def call_function(func_name, func_args, params, system):
    """
    func_args : list of values (int or string)
    
    return str or None if fail
    return ROPChain if success
    """
    if( system == Systems.TargetSystem.Linux and curr_arch_type() == ArchType.ARCH_X86 ):
        return call_function_x86(func_name, func_args, params )
    elif( system == Systems.TargetSystem.Linux and curr_arch_type() == ArchType.ARCH_X64 ):
        return call_function_linux_x64(func_name, func_args, params )
    return "Not implemented yet for this system/arch"

def call_function_linux_x64(func_name, func_args, params):
    arg_regs = [RegX64.RDI, RegX64.RSI, RegX64.RDX, RegX64.RCX, RegX64.R8, RegX64.R9]
    
    # Check how many arguments 
    if( len(func_args) > 6 ):
        return "Doesn't support function call with more than 6 arguments for X64"
    
    # Get function address
    (name, addr) = get_function_address(func_name)
    if( addr is None ):
        return "Couldn't find function '{}' in the binary".format(func_name)
    
    # Check if bad bytes in function address 
    if( not verify_bad_bytes(addr, params.bad_bytes) ):
        return "'{}' address ({}) contains bad bytes".format(func_name, str_special('0x'+format(addr, '0'+str(curr_arch_octets()*2)+'x')))
    
    # Set arguments
    if( func_args ):
        params.lmax -= 1
        # Build the ropchain with the arguments
        args_chain = set_multiple_regs(map(lambda x,y:(x,y) , arg_regs[:len(func_args)], func_args), params)
        if( not args_chain):
            return "Couldn't load arguments in registers"
    else:
        # No arguments 
        args_chain = ROPChain()
    
    args_chain.add_padding(addr, 1, str_ropg(name))
    return args_chain


def call_function_linux_x86(func_name, func_args, params):
    
    # Get function address 
    (name, addr) = get_function_address(func_name)
    if( addr is None ):
        return "Couldn't find function '{}' in the binary".format(func_name)
    
    # Check if bad bytes in function address 
    if( not verify_bad_bytes(addr, params.bad_bytes) ):
        return "'{}' address ({}) contains bad bytes".format(func_name, str_special('0x'+format(addr, '0'+str(curr_arch_octets()*2)+'x')))
    
    # Check if lmax too small
    if( (1 + len(func_args) + (lambda x: 1 if len(x)>0 else 0)(func_args)) > params.lmax ):
        return "Not enough bytes to call function '{}'".format(func_name)
    
    # Find a gadget to skip arguments in the stack when returning
    params.single_gadget = True
    params.no_padding = True
    if( func_args ):
        offset = len(func_args)*curr_arch_octets()
        skip_args_chain = None
        i = 0 # Try 4 bytes more maximum 
        while( i < 5 ):
            tmp_offset = offset + i*curr_arch_octets()
            skip_args_res = search( DestArg(DestType.REG, curr_arch_ip()), AssignArg(AssignType.MEM_BINOP_CST, curr_arch_sp(), Binop.ADD, tmp_offset, 0), params)
            if( skip_args_res.found ):
                skip_args_chain = skip_args_res.chain
                break
            i += 1
            
        if( not skip_args_chain ):
            return "Couldn't find return gadget to execute after function"
    else:
        # No arguments 
        skip_args_chain = ROPChain()
    
    # Build the ropchain with the arguments 
    args_chain = ROPChain()
    arg_n = 1
    for arg in func_args:
        if( isinstance(arg, int) ):
            args_chain.add_padding(arg, 1, comment="Arg{}: {}".format(arg_n, str_ropg(hex(arg))))
            arg_n += 1
        else:
            return "Type of argument '{}' not supported yet :'(".format(arg)
    
    # Build call chain (function address + fake return address)
    call_chain = ROPChain()
    call_chain.add_padding(addr, comment=str_ropg(name))
    call_chain.add_chain(skip_args_chain)
    call_chain.add_chain(args_chain)
    
    # Return res 
    return call_chain
