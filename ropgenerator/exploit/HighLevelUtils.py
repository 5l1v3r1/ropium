# -*- coding:utf-8 -*- 
# Utils module: useful functions to build exploits (more advanced features
# than Utils.py)

from ropgenerator.semantic.Engine import search, LMAX
from ropgenerator.Constraints import Constraint, RegsNotModified, Assertion, Chainable, StackPointerIncrement
from ropgenerator.semantic.ROPChains import ROPChain
from ropgenerator.Database import QueryType
from ropgenerator.exploit.Scanner import getFunctionAddress, findBytes
from ropgenerator.IO import verbose, string_bold, string_special, string_ropg
from ropgenerator.exploit.Call import build_call 
import itertools
import ropgenerator.Architecture as Arch 


#### Put strings in memory

STR_TO_MEM_LMAX = 6000

def STRtoMEM(string, addr, constraint, assertion, lmax=STR_TO_MEM_LMAX ,addr_str=None, hex_info=False, optimizeLen=False):
    """
    Put a string into memory 
    """
    res = STRtoMEM_memcpy(string, addr, constraint, assertion, lmax, addr_str, hex_info)
    if( (not res) or optimizeLen ):
        res2 = STRtoMEM_strcpy(string, addr, constraint, assertion, lmax, addr_str, hex_info)
        if( not res ):
            res = res2
        elif (res2 and ( len(res2) < len(res))):
                res = res2
    return res 

def STRtoMEM_strcpy(string, addr, constraint, assertion, lmax=STR_TO_MEM_LMAX , addr_str=None, hex_info=False):
    """
    STRCPY STRATEGY
    Copy the string using strcpy function 
    """
    if( not addr_str ):
        addr_str = "0x"+format(addr, '0'+str(Arch.octets()*2)+'x')
    
    # Getting strcpy function 
    (func_name, func_addr ) = getFunctionAddress('strcpy')
    if( not func_addr ):
        verbose('Could not find strcpy function')
        return None
    elif( not constraint.badBytes.verifyAddress(func_addr)):
        verbose("strcpy address ({}) contains bad bytes".format(hex(func_addr)))
        return None
    
    # We decompose the string in substrings to be copied
    substrings_addr = findBytes(string, badBytes = constraint.getBadBytes(), add_null=True)
    if( not substrings_addr ):
        return None
    elif( len(substrings_addr)*4 > lmax ):
        verbose("Strcpy: ROP-Chain too long (length: {}, available bytes: {}) ".format(len(substrings_addr)*4*Arch.octets(), lmax*Arch.octets()))
        return None

    # Build chain 
    res = ROPChain()
    offset = 0
    custom_stack = addr
    for (substring_addr,substring_str) in substrings_addr:
        if( hex_info ):
            substring_info = '\\x'+'\\x'.join(["%02x"%ord(c) for c in substring_str])
        else:
            substring_info = substring_str
        commentStack="Arg2: " + string_ropg("{} + {}".format(addr_str, offset))
        commentSubStr="Arg1: " + string_ropg(substring_info)
        func_call = build_call(func_name, [substring_addr, custom_stack], constraint, assertion, [commentSubStr, commentStack] )
        if( isinstance(func_call, str)):
            verbose("Error: " + func_call)
        else:
            res.addChain(func_call)
        # Adjust
        custom_stack = custom_stack + len(substring_str) -1
        offset = offset + len(substring_str) - 1 # Because strcpy has a null byte :/ 

    return res

def STRtoMEM_memcpy(string, addr, constraint, assertion, lmax=STR_TO_MEM_LMAX , addr_str=None, hex_info=False):
    """
    MEMCPY STRATEGY
    Copy the string using memcpy function 
    """
    if( not addr_str ):
        addr_str = "0x"+format(addr, '0'+str(Arch.octets()*2)+'x')
    
    # Getting strcpy function 
    (func_name, func_addr ) = getFunctionAddress('memcpy')
    if( not func_addr ):
        verbose('Could not find memcpy function')
        return None
    elif( not constraint.badBytes.verifyAddress(func_addr)):
        verbose("memcpy address ({}) contains bad bytes".format(hex(func_addr)))
        return None
    
    # We decompose the string in substrings to be copied
    substrings_addr = findBytes(string, badBytes = constraint.getBadBytes())
    if( not substrings_addr ):
        return None
    elif( len(substrings_addr)*5 > lmax ):
        verbose("Memcpy: ROP-Chain too long (length: {}, available bytes: {}) ".format(len(substrings_addr)*5*Arch.octets(), lmax*Arch.octets()))
        return None

    # Build chain 
    res = ROPChain()
    offset = 0 
    custom_stack = addr
    for (substring_addr,substring_str) in substrings_addr:
        if( hex_info ):
            substring_info = "'"+'\\x'+'\\x'.join(["%02x"%ord(c) for c in substring_str])+"'"
        else:
            substring_info = "'"+substring_str+"'"
        comment3 ="Arg3: " + string_ropg(str(len(substring_str)))
        comment2 ="Arg2: " + string_ropg(substring_info)
        comment1 ="Arg1: " + string_ropg("{} + {}".format(addr_str, offset))
        
        func_call = build_call(func_name, [custom_stack, substring_addr, len(substring_str)],\
                    constraint, assertion, [comment1, comment2, comment3])
        
        if( isinstance(func_call, str) ):
            verbose("Error: " + func_call)
            return None
    
        res.addChain(func_call)
    
        # Adjust
        custom_stack = custom_stack + len(substring_str)
        offset = offset + len(substring_str)

    return res
