# -*- coding:utf-8 -*- 
# SycallLinuxX86 module: build syscalls for linux on X64

from ropgenerator.exploit.syscall.SyscallGeneric import Syscall, ArgType
from ropgenerator.core.Architecture import *

mprotect =   Syscall('int', 'mprotect', \
    [('void*', 'addr'),('size_t','len'),('int','prot')], [ArgType.INT, ArgType.INT, ArgType.INT],\
    [RegX86.EBX, RegX86.ECX, RegX86.EDX], [(RegX86.EAX, 0x7d)])

execve = Syscall('int', 'execve', \
    [('char*', 'cmd'),('char**','argv'),('char**', 'envp')], [ArgType.STRING, ArgType.INT,ArgType.INT],\
    [RegX86.EBX,RegX86.ECX,RegX86.EDX], [(RegX86.EAX, 11)] )

read = Syscall('int', 'read', \
    [('unsigned int','fd'),('char*','buf'),('size_t','count')], [ArgType.INT, ArgType.INT_OR_STRING, ArgType.INT], \
    [RegX86.EBX,RegX86.ECX,RegX86.EDX], [(RegX86.EAX, 3)])
    
write = Syscall('int', 'write', \
    [('unsigned int','fd'),('const char*','buf'),('size_t','count')], [ArgType.INT, ArgType.INT, ArgType.INT], \
    [RegX86.EBX,RegX86.ECX,RegX86.EDX], [(RegX86.EAX, 4)])

chmod = Syscall('int', 'chmod', \
    [('const char*','filename'),('mode_t','mode')], [ArgType.INT_OR_STRING, ArgType.INT], \
    [RegX86.EBX, RegX86.ECX], [(RegX86.EAX,15)])
    
setuid = Syscall('int', 'setuid', \
    [('uid_t', 'uid')], [ArgType.INT], \
    [RegX86.EBX], [(RegX86.EAX,23)])

# MMAP with flags = MAP_ANONYMOUS (no fd and offset)
mmap_anon = Syscall('void*', 'mmap_anon', \
    [('unsigned long','addr'),('unsigned long','len'),('unsigned long','prot')],\
    [ArgType.INT, ArgType.INT, ArgType.INT], \
[RegX86.EBX,RegX86.ECX,RegX86.EDX], [(RegX86.EAX,9), ('esi', 0x20)], function="mmap")
    
    
syscalls_list = [mprotect, execve, read, write, chmod, setuid]
## All available syscalls 
available = dict()
for syscall_object in syscalls_list:
    available[syscall_object.name()] = syscall_object

####################
# Useful functions #
####################
def is_supported(syscall_name):
    return (syscall_name in available)

def get_syscall(syscall_name):
    if( not syscall_name in available ):
        return None
    return available[syscall_name]
    
def available_syscalls():
    global available
    return available
