# -*- coding:utf-8 -*- 
# Function module: call functions with ropchains 

from ropgenerator.core.IO import str_special, str_bold, banner, error, str_ropg
from ropgenerator.main.Load import loaded_binary
from ropgenerator.main.Scanner import get_function_address, get_all_functions, set_binary_offset
from ropgenerator.core.ROPChain import *
from ropgenerator.core.ChainingEngine import SearchParametersBinding, get_default_lmax
from ropgenerator.core.Gadget import set_gadgets_offset
from ropgenerator.exploit.ChainingUtils import call_function
from ropgenerator.main.Utils import parse_bad_bytes, parse_keep_regs, parse_function, parse_lmax, parse_offset
from ropgenerator.core.Architecture import *
import ropgenerator.exploit.Systems as Systems 
import sys

#######################
#  FUNCTION COMMAND   # 
#######################

OPTION_OUTPUT = '--output-format'
OPTION_OUTPUT_SHORT = '-f'
# Options for output
OUTPUT_CONSOLE = 'console'
OUTPUT_PYTHON = 'python'
OUTPUT_RAW = 'raw'
OUTPUT = None # The one choosen 

OPTION_BAD_BYTES = '--bad-bytes'
OPTION_BAD_BYTES_SHORT = '-b'

OPTION_CALL = "--call"
OPTION_CALL_SHORT = "-c"

OPTION_KEEP_REGS = '--keep-regs'
OPTION_KEEP_REGS_SHORT = '-k'

OPTION_LIST = "--list"
OPTION_LIST_SHORT = "-l"

OPTION_HELP = "--help"
OPTION_HELP_SHORT = "-h"

OPTION_SHORTEST = '--shortest'
OPTION_SHORTEST_SHORT = '-s'

OPTION_LMAX = '--max-length'
OPTION_LMAX_SHORT = '-m'

OPTION_OFFSET = '--offset'
OPTION_OFFSET_SHORT = '-off'


CMD_FUNCTION_HELP =  banner([str_bold("'function' command"),\
                    str_special("(Call functions with ROPChains)")])
CMD_FUNCTION_HELP += "\n\n\t"+str_bold("Usage:")+\
"\n\t\tfunction [OPTIONS]"
CMD_FUNCTION_HELP += "\n\n\t"+str_bold("Options")+":"
CMD_FUNCTION_HELP += "\n\t\t"+str_special(OPTION_CALL_SHORT)+","+\
    str_special(OPTION_CALL)+" <sys> <func>\t Call a function"
CMD_FUNCTION_HELP += "\n\n\t\t"+str_special(OPTION_BAD_BYTES_SHORT)+","+str_special(OPTION_BAD_BYTES)+" <bytes>\t Bad bytes for payload.\n\t\t\t\t\t Expected format is a list of bytes \n\t\t\t\t\t separated by comas (e.g '-b 0A,0B,2F')"
CMD_FUNCTION_HELP += "\n\n\t\t"+str_special(OPTION_KEEP_REGS_SHORT)+","+str_special(OPTION_KEEP_REGS)+" <regs>\t Registers that shouldn't be modified.\n\t\t\t\t\t Expected format is a list of registers \n\t\t\t\t\t separated by comas (e.g '-k edi,eax')"
CMD_FUNCTION_HELP += "\n\n\t\t"+str_special(OPTION_OFFSET_SHORT)+","+str_special(OPTION_OFFSET)+" <int>\t Offset to add to gadget addresses" 
CMD_FUNCTION_HELP += "\n\n\t\t"+str_special(OPTION_LMAX_SHORT)+","+str_special(OPTION_LMAX)+" <int>\t Max length of the ROPChain in bytes"
CMD_FUNCTION_HELP += "\n\n\t\t"+str_special(OPTION_SHORTEST_SHORT)+","+str_special(OPTION_SHORTEST)+"\t\t Find the shortest matching ROP-Chains"
CMD_FUNCTION_HELP += "\n\n\t\t"+str_special(OPTION_LIST_SHORT)+","+\
    str_special(OPTION_LIST)+"\t\t List available functions"
CMD_FUNCTION_HELP += "\n\n\t\t"+str_special(OPTION_OUTPUT_SHORT)+","+\
    str_special(OPTION_OUTPUT)+\
    " <fmt> Output format for ropchains.\n\t\t\t\t\t Expected format is one of the\n\t\t\t\t\t following: "+\
    str_special(OUTPUT_CONSOLE)+','+str_special(OUTPUT_PYTHON)
    
CMD_FUNCTION_HELP += "\n\n\t\t"+str_special(OPTION_HELP_SHORT)+","+str_special(OPTION_HELP)+"\t\t Show this help"
CMD_FUNCTION_HELP += "\n\n\t"+str_bold("Function format")+": "+\
    str_special("function")+"( "+str_special("arg1")+","+str_special(" ...")+\
    "," + str_special(" argN")+")"
CMD_FUNCTION_HELP += "\n\n\t"+str_bold("Examples")+": "+\
    "\n\t\tfunction -c LINUX strcpy(0x123456, 0x987654)"
    
def print_help():
    print(CMD_FUNCTION_HELP)

def function(args):
    global OUTPUT, OUTPUT_CONSOLE, OUTPUT_PYTHON
    # Parsing arguments
    if( not args):
        print_help()
        return
    OUTPUT = OUTPUT_CONSOLE
    funcName = None
    seenOutput = False
    seenFunction = False
    seenBadBytes = False
    seenKeepRegs = False
    seenShortest = False
    seenLmax = False
    seenOffset = False
    lmax = get_default_lmax()
    offset = 0 
    bad_bytes = []
    keep_regs = []
    
    i = 0
    while i < len(args):
        arg = args[i]
        if( args[i] in [OPTION_LIST, OPTION_LIST_SHORT]):
            if( not loaded_binary() ):
                error("You need to load a binary to get functions to call")
                return 
            func_list = get_all_functions()
            print_functions_list([(name,addr) for name,addr in func_list.items()])
            return 
        if( args[i] in [OPTION_BAD_BYTES, OPTION_BAD_BYTES_SHORT]):
            if( seenBadBytes ):
                error( "'" + arg + "' option should be used only once.")
                return 
            if( i+1 >= len(args)):
                error("Missing bad bytes after option '"+arg+"'")
                return 
            seenBadBytes = True
            (success, bad_bytes) = parse_bad_bytes(args[i+1])
            if( not success ):
                error(bad_bytes)
                return
            i = i+1
        elif( args[i] in [OPTION_KEEP_REGS, OPTION_KEEP_REGS_SHORT]):
            if( seenKeepRegs ):
                error( "'" + arg + "' option should be used only once.")
                return 
            if( i+1 >= len(args)):
                error("Missing registers after option '"+arg+"'")
                return 
            seenKeepRegs = True
            (success, keep_regs) = parse_keep_regs(args[i+1])
            if( not success ):
                error(keep_regs)
                return
            i = i+1
        elif( args[i] in [OPTION_CALL, OPTION_CALL_SHORT] ):
            if( not loaded_binary() ):
                error("You should load a binary before building ROPChains")
                return 
            elif( seenFunction ):
                error("Option '{}' should be used only once".format(args[i]))
                return  
            # Get system
            if( i+1 >= len(args)):
                error("Missing  argument after option '"+arg+"'")
                return
            system = Systems.str_to_target_system(args[i+1])
            if( system is None):
                error("Unsupported system '"+args[i+1]+"'")
                print(str_bold("\tSupported systems")+": "+', '.join([str_special(s) for s in Systems.available_systems_str()]))
                return
            i += 1
            # Get function 
            userInput = ''
            while( i+1 < len(args) and args[i+1][0] != "-"):
                userInput += args[i+1]
                i += 1
            (funcName, funcArgs ) = parse_function(userInput)
            if( not funcName):
                error(funcArgs)
                return
            seenFunction = True
        elif( args[i] in [OPTION_OUTPUT, OPTION_OUTPUT_SHORT]):
            if( seenOutput ):
                error("'" + arg + "' option should be used only once.")
                return 
            if( i+1 >= len(args)):
                error("Missing output format after option '"+arg+"'")
                return 
            if( args[i+1] in [OUTPUT_CONSOLE, OUTPUT_PYTHON]):
                OUTPUT = args[i+1]
                seenOutput = True
                i = i +1
            else:
                error("'" + args[i+1] + "' output format is not supported")
                return  
        elif( args[i] in [OPTION_SHORTEST, OPTION_SHORTEST_SHORT]):
            if( seenShortest ):
                error("'" + arg + "' option should be used only once.")
                return 
            seenShortest = True
        elif( args[i] == OPTION_LMAX or args[i] == OPTION_LMAX_SHORT ):
            if( seenLmax ):
                error("'" + arg + "' option should be used only once.")
                return 
            if( i+1 >= len(args)):
                error("Missing length after option '"+arg+"'")
                return 
            (success, lmax) = parse_lmax(args[i+1])
            if( not success ):
                error(lmax)
                return 
            i = i +1 
            seenLmax = True
        elif( args[i] == OPTION_OFFSET or args[i] == OPTION_OFFSET_SHORT ):
            if( seenOffset ):
                error("'" + arg + "' option should be used only once.")
                return 
            if( i+1 >= len(args)):
                error("Missing output format after option '"+arg+"'")
                return
            (success, offset) = parse_offset(args[i+1])
            if( not success ):
                error(offset)
                return
            i = i+1
            seenOffset = True
        elif( args[i] in [OPTION_HELP, OPTION_HELP_SHORT]):
            print_help()
            return 
        else:
            error("Error. Unknown option '{}'".format(args[i]))
            return 
        i = i + 1
    
    # If parsing successful, build ROPChain to call function
    if( not funcName ):
        error("Missing function to call")
        return 
    else:
        # Set offset 
        set_gadgets_offset(offset)
        set_binary_offset(offset)
        # Prepare parameters
        params = SearchParametersBinding(keep_regs, bad_bytes, lmax, seenShortest)
        res_chain = call_function(funcName, funcArgs, params, system)
        if( res_chain is None ):
            error("No matching ROPChain found")
        elif( isinstance(res_chain, str) ):
            error(res_chain)
        else:
            # Print result
            if( OUTPUT == OUTPUT_CONSOLE ):
                print(res_chain.to_str_console(curr_arch_octets(), bad_bytes ))
            elif( OUTPUT == OUTPUT_PYTHON ):
                print(res_chain.to_str_python(curr_arch_octets(), bad_bytes, True, False ))
        # Reset offset 
        set_gadgets_offset(0)
        set_binary_offset(0)

def print_functions_list(func_list):
    """
    func_list - list of pairs (str, int) = (funcName, funcAddress)
    """
    space = 28
    
    print(str_bold("\n\tFunction" + " "*(space-8) + "Address"))
    print("\t------------------------------------")
    for (funcName, funcAddr) in sorted(func_list, key=lambda x:x[0] ):
        space2 = space - len(funcName)
        if( space2 < 0 ):
            space2 = 2
        print("\t"+str_special(funcName)+ " "*space2 + hex(funcAddr))
    print("")

