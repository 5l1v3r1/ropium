# -*- coding:utf-8 -*- 
# Scanner module: Scan binaries to get useful infos for exploits 

import subprocess
from ropgenerator.exploit.ZwoELF import ElfParser
import mmap
import re
from ropgenerator.Gadget import Gadget
import ropgenerator.Architecture as Arch

binary_name = None
binary_ELF = None

def initScanner(filename):
    global binary_name
    global binary_ELF
    
    binary_name = filename
    if( Arch.currentIsELF()):
        binary_ELF = ElfParser(binary_name)
    else:
        binary_ELF = None

def getAllFunctions():
    """
    Return a list of all functions for relocation entries
    """
    global binary_ELF
    return [(rela.symbol.symbolName, rela.r_offset ) for rela in binary_ELF.jumpRelocationEntries]
        

def getSectionAddress(name):
    """
    Returns the address of a segment in the loaded binary 
    """ 
    global binary_ELF
    section = binary_ELF.getSectionByName(name)
    return section.elfN_shdr.sh_offset
     
        
def getFunctionAddress(name):
    """
    Looks for the function 'name' in the PLT of a binary 
    Returns a pair (name, address) as (str, int)
    """
    global binary_name
    global binary_ELF
    
    if( not Arch.currentIsELF()):
        return (None, None)
        
    for rela in binary_ELF.jumpRelocationEntries:
        if( rela.symbol.symbolName == name ):
            return ( rela.symbol.symbolName, rela.r_offset)
    return (None, None)

def findBytes(byte_string, badBytes = [], add_null=False ):
    """
    Find a string in a file + additionnal null byte at the end
    
    Parameters
    ----------
    badbytes : bad bytes for substrings addresses
    add_null : if True then add terminaison null bytes in the end of the substrings 
    
    Example: 
        byte_string = 'abc' then result is the address of a string 'abc\x00'
        or a list of addresses s.t elements form 'abc' like 'ab\x00' 'c\x00' 
    """
    
    def _find_substr(m,string):
        if( not string ):
            return [-1,0]
        # Initialize
        offset = -1
        index = len(string)
        substring = string
        # Search biggest substring 
        while( offset == -1 ):
            if( len(substring) <= 0 ):
                return [-1,0]
            offset = m.find(substring)
            if( offset != -1 ):
                return [offset, index]
            else:
                substring = substring[:-1]
            index = index -1
    
    def _find_substr_add_null(m, string):
        if( not string ):
            return [-1,0]
        # Initialize
        offset = -1
        index = len(string)
        last_is_null = (string[-1] == '\x00')
        if( not last_is_null ):
            substring = string + '\x00'
        else:
            substring = string
        # Search biggest substring 
        while( offset == -1 ):
            if( len(substring) <= 0 ):
                return [-1,0]
            offset = m.find(substring)
            if( offset != -1 ):
                return [offset, index]
            else:
                substring = substring[:-2]
                if( not substring ):
                    return [-1,0]
                last_is_null = (substring[-1] == '\x00')    
                if( not last_is_null ):
                    substring = substring + '\x00'
            index = index -1
    
    def _verify_bad_bytes(addr, badBytes):
        addrBytes = re.findall('..',('{:'+'{:02d}'\
            .format(Arch.currentArch.octets)+'x}').format(addr))
        for byte in badBytes:
            if( byte in addrBytes):
                return False
        return True
        
    # Function body 
    global binary_name
    global binary_ELF
        
    text = binary_ELF.getSectionByName(".text")
    if( not text ):
        return []
    start = text.elfN_shdr.sh_offset
    end = text.elfN_shdr.sh_offset + text.elfN_shdr.sh_size
    m = binary_ELF.data[start:end]
    
    res = []
    substring = str(byte_string)
    while( substring ):
        found = False
        m_tmp = str(m)
        while( not found ):
            if( not m_tmp ):
                return []
            # Get substring address 
            if( add_null ):
                (offset, index ) = _find_substr_add_null(m_tmp, substring)
            else:
                (offset, index ) = _find_substr(m_tmp, substring)
            # We didn't find any match, return empty list 
            if( index == 0 ):
                return []
            # Check for bad bytes in the address 
            if( _verify_bad_bytes(start+offset, badBytes)):
                found = True
            else:
                m_tmp = m_tmp[offset:]
                
        # We add the best substring we found
        if( add_null ):
            res.append([start+offset,substring[:index]+"\x00"])
        else:
            res.append([start+offset,substring[:index]])
        substring = substring[index:]

    return res
