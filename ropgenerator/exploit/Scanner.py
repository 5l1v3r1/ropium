# -*- coding:utf-8 -*- 
# Scanner module: Scan binaries to get useful infos for exploits 

import subprocess
from ropgenerator.exploit.ZwoELF import ElfParser
import mmap
import re
from ropgenerator.Gadget import Gadget
import ropgenerator.Architecture as Arch

binary_name = None
binary_ELF = None

def initScanner(filename):
    global binary_name
    global binary_ELF
    
    binary_name = filename
    if( Arch.currentIsELF()):
        binary_ELF = ElfParser(binary_name)
    else:
        binary_ELF = None
        
def getFunctionAddress(name):
    """
    Looks for the function 'name' in the PLT of a binary 
    Returns a pair (name, address) as (str, int)
    """
    global binary_name
    global binary_ELF
    
    if( not Arch.currentIsELF()):
        return (None, None)
        
    for rela in binary_ELF.jumpRelocationEntries:
        if( rela.symbol.symbolName == name ):
            return ( rela.symbol.symbolName, rela.r_offset)
    return (None, None)

def findBytes(byte_string, badBytes = [], add_null=False ):
    """
    Find a string in a file + additionnal null byte at the end
    
    Parameters
    ----------
    badbytes : bad bytes for substrings addresses
    add_null : if True then add terminaison null bytes in the end of the substrings 
    
    Example: 
        byte_string = 'abc' then result is the address of a string 'abc\x00'
        or a list of addresses s.t elements form 'abc' like 'ab\x00' 'c\x00' 
    """
    
    def _find_substr(m,string):
        if( not string ):
            return [-1,0]
        # Initialize
        offset = -1
        index = len(string)
        substring = string
        # Search biggest substring 
        while( offset == -1 ):
            if( len(substring) <= 0 ):
                return [-1,0]
            offset = m.find(substring)
            if( offset != -1 ):
                return [offset, index]
            else:
                substring = substring[:-1]
            index = index -1
    
    def _find_substr_add_null(m, string):
        if( not string ):
            return [-1,0]
        # Initialize
        offset = -1
        index = len(string)
        last_is_null = (string[-1] == '\x00')
        if( not last_is_null ):
            substring = string + '\x00'
        else:
            substring = string
        # Search biggest substring 
        while( offset == -1 ):
            if( len(substring) <= 0 ):
                return [-1,0]
            offset = m.find(substring)
            if( offset != -1 ):
                return [offset, index]
            else:
                substring = substring[:-2]
                if( not substring ):
                    return [-1,0]
                last_is_null = (substring[-1] == '\x00')    
                if( not last_is_null ):
                    substring = substring + '\x00'
            index = index -1
        
    global binary_name
    global binary_ELF
   
    if( badBytes ):
        error("DEBUG, in finBytes(): badBytes not supported yet")
        return []
        
    text = binary_ELF.getSectionByName(".text")
    if( not text ):
        return []
    start = text.elfN_shdr.sh_offset
    end = text.elfN_shdr.sh_offset + text.elfN_shdr.sh_size
    m = binary_ELF.data[start:end]
    
    res = []
    substring = str(byte_string)
    while( substring ):
        if( add_null ):
            (offset, index ) = _find_substr_add_null(m, substring)
        else:
            (offset, index ) = _find_substr(m, substring)
        if( index == 0 ):
            # We didn't find any match, return empty list 
            return []
        else:
            # We add the best substring we found 
            res.append([start+offset,substring[:index]])
            substring = substring[index:]
    return res
