# -*- coding:utf-8 -*- 
# Syscall module: building ropchains performing syscalls
from ropgenerator.IO import string_special, banner, string_bold, error
from enum import Enum
import ropgenerator.exploit.syscalls.Linux32 as Linux32
import ropgenerator.exploit.syscalls.Linux64 as Linux64
import ropgenerator.Architecture as Arch
from ropgenerator.Load import loadedBinary

#####################
# Available systems #
#####################
sysLinux32 = "LINUX32"
sysLinux64 = "LINUX64"

availableSystems = [sysLinux32, sysLinux64]

###################
# SYSCALL COMMAND #
###################

OPTION_OUTPUT = '--output-format'
OPTION_OUTPUT_SHORT = '-f'
# Options for output
OUTPUT_CONSOLE = 'console'
OUTPUT_PYTHON = 'python'
OUTPUT_RAW = 'raw'
OUTPUT = None # The one choosen 

OPTION_LIST = "--list"
OPTION_LIST_SHORT = "-l"

OPTION_FUNCTION = "--call"
OPTION_FUNCTION_SHORT = "-c" 

OPTION_HELP = "--help"
OPTION_HELP_SHORT = "-h"

CMD_SYSCALL_HELP =  banner([string_bold("'syscall' command"),\
                    string_special("(Call system functions with ROPChains)")])
CMD_SYSCALL_HELP += "\n\n\t"+string_bold("Usage:")+\
"\n\t\tsyscall [OPTIONS]"
CMD_SYSCALL_HELP += "\n\n\t"+string_bold("Options")+":"
CMD_SYSCALL_HELP += "\n\t\t"+string_special(OPTION_FUNCTION_SHORT)+","+\
    string_special(OPTION_FUNCTION)+" <function>\t Call a system function"
CMD_SYSCALL_HELP += "\n\n\t\t"+string_special(OPTION_LIST_SHORT)+","+\
    string_special(OPTION_LIST)+" [<system>]\t List supported functions"
CMD_SYSCALL_HELP += "\n\n\t\t"+string_special(OPTION_OUTPUT_SHORT)+","+\
    string_special(OPTION_OUTPUT)+\
    " <fmt> Output format for ropchains.\n\t\t\t\t\t Expected format is one of the\n\t\t\t\t\t following: "+\
    string_special(OUTPUT_CONSOLE)+','+string_special(OUTPUT_PYTHON)
    
CMD_SYSCALL_HELP += "\n\n\t\t"+string_special(OPTION_HELP_SHORT)+","+string_special(OPTION_HELP)+"\t\t Show this help"
CMD_SYSCALL_HELP += "\n\n\t"+string_bold("Supported systems")+": "+', '.join([string_special(s) for s in availableSystems])
CMD_SYSCALL_HELP += "\n\n\t"+string_bold("Function format")+": "+\
    string_special("function")+"( "+string_special("arg1")+","+string_special(" ...")+\
    "," + string_special(" argN")+")"
CMD_SYSCALL_HELP += "\n\n\t"+string_bold("Examples")+": "+\
    "\n\t\tsyscall -f python -c mprotect32(0x123456, 200, 7)\n\t\tsyscall -l LINUX64"
def print_help():
    print(CMD_SYSCALL_HELP)


def syscall(args):
    global OUTPUT, OUTPUT_CONSOLE, OUTPUT_PYTHON
    # Parsing arguments
    if( not args):
        print_help()
        return
    OUTPUT = OUTPUT_CONSOLE
    funcName = None
    i = 0
    seenOutput = False
    seenFunction = False
    while i < len(args):
        if( args[i] in [OPTION_LIST, OPTION_LIST_SHORT]):
            listSyscalls(args[1:])
            return 
        elif( args[i] in [OPTION_FUNCTION, OPTION_FUNCTION_SHORT] ):
            if( not loadedBinary() ):
                error("Error. You should lado a binary before building ROPChains")
                return 
            elif( seenFunction ):
                error("Option '{}' should be used only once".format(args[i]))
                return  
            userInput = ''
            i +=1
            while( i < len(args) and args[i][0] != "-"):
                userInput += args[i]
                i += 1
            (funcName, funcArgs ) = parseFunction(userInput)
            if( not funcName):
                return 
            seenFunction = True
        elif( args[i] in [OPTION_OUTPUT, OPTION_OUTPUT_SHORT]):
            if( seenOutput ):
                error("Option '{}' should be used only once".format(args[i]))
                return 
            if( i+1 >= len(args)):
                error("Error. Missing output format after option '"+args[i]+"'")
                return 
            if( args[i+1] in [OUTPUT_CONSOLE, OUTPUT_PYTHON]):
                OUTPUT = args[i+1]
                seenOutput = True
                i += 2
            else:
                error("Error. Unknown output format: {}".format(args[i+1]))
                return 
        elif( args[i] in [OPTION_HELP, OPTION_HELP_SHORT]):
            print_help()
            return 
        else:
            error("Error. Unknown option '{}'".format(args[i]))
            return 
    
    if( not funcName ):
        error("Missing function to call")
    else:
        call(funcName, funcArgs)

def call(funcName, parsedArgs):
    # Get target system
    if( Arch.currentBinType == Arch.BinaryType.X86_ELF ):
        syscall = Linux32.available.get(funcName)
        system = sysLinux32
    elif( Arch.currentBinType == Arch.BinaryType.X64_ELF ):
        syscall = Linux64.available.get(funcName)
        system = sysLinux64
    else:
        error("Binary type '{}' not supported yet".format(Arch.currentBinType))
        return 
    
    if( not syscall ):
        error("Syscall '{}' not supported for system '{}'".format(\
        funcName, system))
        return 
    
    if( len(parsedArgs) != len(syscall.args)):
        error("Error. Wrong number of arguments")
        return 
        
    # Build syscall
    res = _build_syscall(syscall.buildFunc, parsedArgs)
    # Print result 
    if( not res ):
        print(string_bold("\n\tNo matching ROPChain found"))
    else:
        print(string_bold("\n\tFound matching ROPChain\n"))
        badBytes = []
        if( OUTPUT == OUTPUT_CONSOLE ):
            print(res.strConsole(Arch.bits(), badBytes))
        elif( OUTPUT == OUTPUT_PYTHON ):
            print(res.strPython(Arch.bits(), badBytes))
    
    
def _build_syscall(funcPointer, args ):
    if( len(args) == 0 ):
        return funcPointer()
    elif( len(args) == 1 ):
        return funcPointer(args[0])
    elif( len(args) == 2 ):
        return funcPointer(args[0], args[1])
    elif( len(args) == 3 ):
        return funcPointer(args[0], args[1], args[2])
    elif( len(args) == 4 ):
        return funcPointer(args[0], args[1], args[2], args[3])
    elif( len(args) == 5 ):
        return funcPointer(args[0], args[1], args[2], args[3], args[4])
    else:
        error("{}-arguments calls not supported".format(len(args)))
        return []

def listSyscalls(args):
    if( not args ):
        systems = availableSystems
    else:
        systems = []
        for arg in args:
            if( arg in availableSystems ):
                systems.append(arg)
            else:
                error("Unknown system: '{}'".format(arg))
                return 
    
    for system in list(set(systems)):
        if( system == sysLinux32 ):
            Linux32.print_available()
        elif( system == sysLinux64 ):
            Linux64.print_available()


def parseFunction(string):
    def seek(char, string):
        for i in range(0, len(string)):
            if string[i] == char:
                return (string[:i], i)
        return ([],-1)
        
    if( not string ):
        error("Missing fuction to call")
        return (None, None)
    
    # COmpress the string
    string = "".join(string.split())
    
    # Get the function name 
    (funcName, index) = seek("(", string)
    if( not funcName ):
        error("Invalid function call")
        return (None, None)
    rest = string[index+1:]
    args = []
    arg = ''
    i = 0
    end = False
    while(i < len(rest)):
        c = rest[i]
        # No args
        if( c == ")" and not args):
            end = True
            i += 1
        # String
        elif( c == '"' or c == "'" ):
            (s, index)= seek(c, rest[i+1:])
            if( not s ):
                error("Missing closing {} for string".format(c))
                return (None, None)
            args.append(s)
            i += index +2
            if( i >= len(rest)):
                error("Error. Missing ')'")
                return (None, None)
            elif( rest[i] == ')' ):
                end = True
                i += 1
            elif( rest[i] == "," ):
                i += 1
        # Constant
        else:
            # Get the constant 
            arg = ''
            ok = False
            for j in range(i, len(rest)):
                if( rest[j] == ")" ):
                    end = True
                    ok = True
                    break
                elif( rest[j] == ','):
                    ok = True
                    break
                else:
                    arg += rest[j]
            if( not ok ):
                error("Missing ')' after argument")
                return (None, None)
            if( (not arg) and args):
                error("Missing argument")
                return (None, None)
            # Convert to int 
            try:
                value = int(arg)
            except:
                try:
                    value = int(arg, 16)
                except:
                    try:
                        value = int(arg, 2)
                    except:
                        error("Invalid operand: " + arg )
                        return (None, None)
            args.append(value)
            i = j+1
        if( end):
            break
    
    if( not end ):
        error("Error. Missing ')'")
        return    (None, None)     
    if( i < len(rest)):
        error("Error. Extra argument: {}".format(rest[i:]))
        return (None, None)

    return (funcName, args)
    

