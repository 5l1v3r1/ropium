# -*- coding:utf-8 -*- 
# Syscall module: building ropchains performing syscalls
from ropgenerator.core.IO import str_special, banner, str_bold, error
from enum import Enum


from ropgenerator.main.Utils import parse_function, parse_offset, parse_keep_regs, parse_bad_bytes
from ropgenerator.core.Architecture import *
from ropgenerator.main.Load import loaded_binary
from ropgenerator.core.Gadget import set_gadgets_offset
from ropgenerator.main.Scanner import set_binary_offset
from ropgenerator.core.ChainingEngine import *
import ropgenerator.exploit.syscall.SyscallLinuxX64 as LinuxX64
import ropgenerator.exploit.syscall.SyscallLinuxX86 as LinuxX86
from ropgenerator.core.IO import *

#####################
# Available systems #
#####################
sys_linux_x86 = "LINUX_X86"
sys_linux_x64 = "LINUX_X64"

syscall_available_systems = [sys_linux_x86, sys_linux_x64]

###################
# SYSCALL COMMAND #
###################

OPTION_OUTPUT = '--output-format'
OPTION_OUTPUT_SHORT = '-f'
# Options for output
OUTPUT_CONSOLE = 'console'
OUTPUT_PYTHON = 'python'
OUTPUT_RAW = 'raw'
OUTPUT = None # The one choosen 

OPTION_BAD_BYTES = '--bad-bytes'
OPTION_BAD_BYTES_SHORT = '-b'

OPTION_KEEP_REGS = '--keep-regs'
OPTION_KEEP_REGS_SHORT = '-k'

OPTION_LIST = "--list"
OPTION_LIST_SHORT = "-l"

OPTION_FUNCTION = "--call"
OPTION_FUNCTION_SHORT = "-c" 

OPTION_OFFSET="--offset"
OPTION_OFFSET_SHORT = "-off"

OPTION_HELP = "--help"
OPTION_HELP_SHORT = "-h"

CMD_SYSCALL_HELP =  banner([str_bold("'syscall' command"),\
                    str_special("(Call system functions with ROPChains)")])
CMD_SYSCALL_HELP += "\n\n\t"+str_bold("Usage:")+\
"\n\t\tsyscall [OPTIONS]"
CMD_SYSCALL_HELP += "\n\n\t"+str_bold("Options")+":"
CMD_SYSCALL_HELP += "\n\t\t"+str_special(OPTION_FUNCTION_SHORT)+","+\
    str_special(OPTION_FUNCTION)+" <sys> <func>\t Call a system function"
CMD_SYSCALL_HELP += "\n\n\t\t"+str_special(OPTION_BAD_BYTES_SHORT)+","+str_special(OPTION_BAD_BYTES)+" <bytes>\t Bad bytes for payload.\n\t\t\t\t\t Expected format is a list of bytes \n\t\t\t\t\t separated by comas (e.g '-b 0A,0B,2F')"
CMD_SYSCALL_HELP += "\n\n\t\t"+str_special(OPTION_KEEP_REGS_SHORT)+","+str_special(OPTION_KEEP_REGS)+" <regs>\t Registers that shouldn't be modified.\n\t\t\t\t\t Expected format is a list of registers \n\t\t\t\t\t separated by comas (e.g '-k edi,eax')"
CMD_SYSCALL_HELP += "\n\n\t\t"+str_special(OPTION_OFFSET_SHORT)+","+\
    str_special(OPTION_OFFSET)+" <int>\t Offset to add to gadget addresses"   
    
CMD_SYSCALL_HELP += "\n\n\t\t"+str_special(OPTION_LIST_SHORT)+","+\
    str_special(OPTION_LIST)+" [<system>]\t List supported functions"
CMD_SYSCALL_HELP += "\n\n\t\t"+str_special(OPTION_OUTPUT_SHORT)+","+\
    str_special(OPTION_OUTPUT)+\
    " <fmt> Output format for ropchains.\n\t\t\t\t\t Expected format is one of the\n\t\t\t\t\t following: "+\
    str_special(OUTPUT_CONSOLE)+','+str_special(OUTPUT_PYTHON)
    
CMD_SYSCALL_HELP += "\n\n\t\t"+str_special(OPTION_HELP_SHORT)+","+str_special(OPTION_HELP)+"\t\t Show this help"
CMD_SYSCALL_HELP += "\n\n\t"+str_bold("Supported systems")+": "+', '.join([str_special(s) for s in syscall_available_systems])
CMD_SYSCALL_HELP += "\n\n\t"+str_bold("Function format")+": "+\
    str_special("function")+"( "+str_special("arg1")+","+str_special(" ...")+\
    "," + str_special(" argN")+")"
CMD_SYSCALL_HELP += "\n\n\t"+str_bold("Examples")+": "+\
    "\n\t\tsyscall -f python -c mprotect(0x123456, 200, 7)"+\
    "\n\t\tsyscall -c execve('/bin/sh\x00', 0, 0)"+\
    "\n\t\tsyscall -l LINUX64"
    
def print_help():
    print(CMD_SYSCALL_HELP)

def syscall(args):
    global OUTPUT, OUTPUT_CONSOLE, OUTPUT_PYTHON

    if( not args):
        print_help()
        return
    OUTPUT = OUTPUT_CONSOLE
    funcName = None
    offset = 0
    i = 0
    seenOutput = False
    seenFunction = False
    seenBadBytes = False
    seenKeepRegs = False
    seenOffset = False
    seenShortest = False
    bad_bytes = []
    keep_regs = []
    lmax = get_default_lmax() # DEBUG arbitrary ?
    
    # Parsing arguments
    while i < len(args):
        arg = args[i]
        if( args[i] in [OPTION_LIST, OPTION_LIST_SHORT]):
            list_syscalls(args[1:]) # TODO 
            return 
        if( args[i] in [OPTION_BAD_BYTES, OPTION_BAD_BYTES_SHORT]):
            if( seenBadBytes ):
                error( "'" + arg + "' option should be used only once.")
                return 
            if( i+1 >= len(args)):
                error("Missing bad bytes after option '"+arg+"'")
                return 
            seenBadBytes = True
            (success, bad_bytes) = parse_bad_bytes(args[i+1])
            if( not success ):
                error(bad_bytes)
                return
            i = i+1
        elif( args[i] in [OPTION_KEEP_REGS, OPTION_KEEP_REGS_SHORT]):
            if( seenKeepRegs ):
                error( "'" + arg + "' option should be used only once.")
                return 
            if( i+1 >= len(args)):
                error("Missing registers after option '"+arg+"'")
                return 
            seenKeepRegs = True
            (success, keep_regs) = parse_keep_regs(args[i+1])
            if( not success ):
                error(keep_regs)
                return
            i = i+1
        elif( args[i] == OPTION_OFFSET or args[i] == OPTION_OFFSET_SHORT ):
            if( seenOffset ):
                error("'" + arg + "' option should be used only once.")
                return 
            if( i+1 >= len(args)):
                error("Missing output format after option '"+arg+"'")
                return
            (success, offset) = parse_offset(args[i+1])
            if( not success ):
                error(offset)
                return
            i = i+1
            seenOffset = True
        elif( args[i] in [OPTION_FUNCTION, OPTION_FUNCTION_SHORT] ):
            if( not loaded_binary() ):
                error("You should load a binary before building ROPChains")
                return 
            elif( seenFunction ):
                error("Option '{}' should be used only once".format(args[i]))
                return  
            userInput = ''
            if( i+1 >= len(args)):
                error("Missing  argument after option '"+arg+"'")
                return
            system = args[i+1]
            if( system not in syscall_available_systems):
                error("Unsupported system '"+system+"'")
                print(str_bold("\tSupported systems")+": "+', '.join([str_special(s) for s in syscall_available_systems]))
                return
            i += 1
            while( i+1 < len(args) and args[i+1][0] != "-"):
                userInput += args[i+1]
                i += 1
            (funcName, funcArgs ) = parse_function(userInput)
            if( not funcName):
                error(funcArgs)
                return
            seenFunction = True
        elif( args[i] in [OPTION_OUTPUT, OPTION_OUTPUT_SHORT]):
            if( seenOutput ):
                error("'" + arg + "' option should be used only once.")
                return 
            if( i+1 >= len(args)):
                error("Missing output format after option '"+arg+"'")
                return 
            if( args[i+1] in [OUTPUT_CONSOLE, OUTPUT_PYTHON]):
                OUTPUT = args[i+1]
                seenOutput = True
                i = i +1
            else:
                error("'" + args[i+1] + "' output format is not supported")
                return  
        elif( args[i] in [OPTION_HELP, OPTION_HELP_SHORT]):
            print_help()
            return 
        else:
            error("Error. Unknown option '{}'".format(args[i]))
            return 
        i += 1

    # Do the search 
    if( not funcName ):
        error("Missing function to call")
        return 
    else:
        # Set offset 
        set_gadgets_offset(offset)
        set_binary_offset(offset)
        
        # Make syscall 
        params = SearchParametersBinding(keep_regs, bad_bytes, lmax, seenShortest)
        res = build_syscall(funcName, funcArgs, params, system)
        # Print result 
        if( res is None ):
            error("No matching ROPChain found")
        elif( isinstance(res, str) ):
            error(res)
            return 
        else:
            if( OUTPUT == OUTPUT_CONSOLE ):
                print(res.to_str_console(curr_arch_octets(), bad_bytes ))
            elif( OUTPUT == OUTPUT_PYTHON ):
                print(res.to_str_python(curr_arch_octets(), bad_bytes, True, False ))
        
        # Reset offset 
        set_gadgets_offset(0)
        set_binary_offset(0)
            

def build_syscall(func_name, parsed_args, params, system):
    """
    Make a syscall ROPChain
    system: one of syscall_available_systems
    """
    # Get target system
    if( system == sys_linux_x86 ):
        syscall = LinuxX86.get_syscall(func_name)
    elif( system == sys_linux_x64 ):
        syscall = LinuxX64.get_syscall(func_name)
    else:
        return ("System '{}' not supported yet".format(Arch.currentBinType))
    
    if( not syscall ):
        return ("Syscall '{}' not supported for system '{}'".format(\
        func_name, system))
    
    if( len(parsed_args) != syscall.nb_args()):
        return ("Error. Wrong number of arguments")

    # Build syscall
    return syscall.build(parsed_args, params)



def print_syscalls_list(syscall_dict):
    print("\t--------------------------------")
    for name in sorted(syscall_dict.keys()):
        print("\n\t"+str_payload(name)+":  "+str(syscall_dict[name]))

def list_syscalls(args):
    if( not args ):
        systems = syscall_available_systems # TODO , take the one corredonding to the loaded binary if there is one
    else:
        systems = []
        for arg in args:
            if( arg in syscall_available_systems ):
                systems.append(arg)
            else:
                error("Unknown system: '{}'".format(arg))
                return 
    
    for system in list(set(systems)):
        if( system == sys_linux_x86):
            available = LinuxX86.available_syscalls()
            print(str_bold("\n\n\tSupported Linux X86 syscalls"))
            print_syscalls_list(available)
        elif( system == sys_linux_x64):
            available = LinuxX64.available_syscalls()
            print(str_bold("\n\n\tSupported Linux X64 syscalls"))
            print_syscalls_list(available)
            
