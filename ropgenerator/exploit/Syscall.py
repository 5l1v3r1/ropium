# -*- coding:utf-8 -*- 
# Syscall module: building ropchains performing syscalls
from ropgenerator.IO import string_special, banner, string_bold, error
from enum import Enum
import ropgenerator.exploit.syscalls.Linux32 as Linux32
import ropgenerator.exploit.syscalls.Linux64 as Linux64

#####################
# Available systems #
#####################
sysLinux32 = "LINUX32"
sysLinux64 = "LINUX64"

availableSystems = [sysLinux32, sysLinux64]

###################
# SYSCALL COMMAND #
###################

OPTION_LIST = "--list"
OPTION_LIST_SHORT = "-l"

OPTION_FUNCTION = "--function"
OPTION_FUNCTION_SHORT = "-f" 

OPTION_HELP = "--help"
OPTION_HELP_SHORT = "-h"

CMD_SYSCALL_HELP =  banner([string_bold("'syscall' command"),\
                    string_special("(Call system functions with ROPChains)")])
CMD_SYSCALL_HELP += "\n\n\t"+string_bold("Usage:")+\
"\n\t\tsyscall [OPTION]"
CMD_SYSCALL_HELP += "\n\n\t"+string_bold("Options")+":"
CMD_SYSCALL_HELP += "\n\t\t"+string_special(OPTION_FUNCTION_SHORT)+","+\
    string_special(OPTION_FUNCTION)+" <function> Call a system function"
CMD_SYSCALL_HELP += "\n\t\t"+string_special(OPTION_LIST_SHORT)+","+\
    string_special(OPTION_LIST)+" [<system>]\t List supported functions"

CMD_SYSCALL_HELP += "\n\t\t"+string_special(OPTION_HELP_SHORT)+","+string_special(OPTION_HELP)+"\t\t Show this help"
CMD_SYSCALL_HELP += "\n\n\t"+string_bold("Supported systems")+": "+', '.join([string_special(s) for s in availableSystems])
CMD_SYSCALL_HELP += "\n\n\t"+string_bold("Function format")+": "+\
    string_special("function")+"( "+string_special("arg1")+","+string_special(" ...")+\
    "," + string_special(" argN")+")"
CMD_SYSCALL_HELP += "\n\n\t"+string_bold("Examples")+": "+\
    "\n\t\tsyscall -f mprotect32(0x123456, 200, 7)\n\t\tsyscall -l LINUX64"
def print_help():
    print(CMD_SYSCALL_HELP)


def syscall(args):
    # Parsing arguments
    if( not args):
        print_help()
        return 
    if( args[0] in [OPTION_LIST, OPTION_LIST_SHORT]):
        listSyscalls(args[1:])
    elif( args[0] in [OPTION_FUNCTION, OPTION_FUNCTION_SHORT] ):
        function(args[1:])
    elif( args[0] in [OPTION_HELP, OPTION_HELP_SHORT]):
        print_help()
    else:
        error("Error. Unknown option '{}'".format(args[0]))
    return 

def function(args):
    if( not args ):
        error("Missing function call")
        return 
    # Parse arguments 
    parsedArgs = parseFunction(''.join(args))
    


def listSyscalls(args):
    if( not args ):
        systems = availableSystems
    else:
        systems = []
        for arg in args:
            if( arg in availableSystems ):
                systems.append(arg)
            else:
                error("Unknown system: '{}'".format(arg))
                return 
    
    for system in list(set(systems)):
        if( system == sysLinux32 ):
            Linux32.print_available()
        elif( system == sysLinux64 ):
            Linux64.print_available()


def parseFunction(string):
    def seek(char, string):
        for i in range(0, len(string)):
            if string[i] == char:
                return (string[:i], i)
        return ([],-1)
        
    # COmpress the string
    string = "".join(string.split())
    
    # Get the function name 
    (funcName, index) = seek("(", string)
    if( not funcName ):
        error("Invalid function call")
        return 
    rest = string[index+1:]
    args = []
    arg = ''
    i = 0
    end = False
    while(i < len(rest)):
        c = rest[i]
        # No args
        if( c == ")" and not args):
            end = True
            i += 1
        # String
        elif( c == '"' or c == "'" ):
            (s, index)= seek(c, rest[i+1:])
            if( not s ):
                error("Missing closing {} for string".format(c))
                return 
            args.append(s)
            i += index +2
            if( i >= len(rest)):
                error("Error. Missing ')'")
                return 
            elif( rest[i] == ')' ):
                end = True
                i += 1
            elif( rest[i] == "," ):
                i += 1
        # Constant
        else:
            # Get the constant 
            arg = ''
            ok = False
            for j in range(i, len(rest)):
                if( rest[j] == ")" ):
                    end = True
                    ok = True
                    break
                elif( rest[j] == ','):
                    ok = True
                    break
                else:
                    arg += rest[j]
            if( not ok ):
                error("Missing ')' after argument")
                return 
            if( (not arg) and args):
                error("Missing argument")
                return 
            # Convert to int 
            try:
                value = int(arg)
            except:
                try:
                    value = int(arg, 16)
                except:
                    try:
                        value = int(arg, 2)
                    except:
                        error("Invalid operand: " + arg )
                        return 
            args.append(value)
            i = j+1
        if( end):
            break
    
    if( not end ):
        error("Error. Missing ')'")
        return         
    if( i < len(rest)):
        error("Error. Extra argument: {}".format(rest[i:]))
        return 

    return args
