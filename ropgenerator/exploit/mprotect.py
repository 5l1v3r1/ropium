## Functions to call mprotect with a ropchain
from ropgenerator.SearchEngine import search
from ropgenerator.Gadget import GadgetType
import ropgenerator.Analysis as Analysis
from ropgenerator.Constraints import Constraint, ConstraintType
from itertools import permutations

def pop_multiple(args, constraint=Constraint()):
    """
    args is a list of pairs (reg, value)
    Creates a chain that pops values into regs
    """
    res = []
    for arg in args:
        pop = search.find(GadgetType.CSTtoREG, Analysis.regNamesTable[arg[0]], arg[1], constraint)
        if( not pop ):
            return []
        else:
            res += pop[0]
            constraint = constraint.add(ConstraintType.REGS_NOT_MODIFIED, [Analysis.regNamesTable[arg[0]]]))
    return res
            
def mprotect_X86():
    """
    Call mprotect from X86 arch
    Args must be on the stack:
    int mprotect(void *addr, size_t len, int prot)
    """

    # We have to do an interuption INT 80
    # With eax = 0x7d (sys_mprotect)
    return []
    
    
    
def mprotect_X64(addr, size, prot=7, constraint=Constraint()):
    """
    Call mprotect from X86-64 arch
    Args must be on registers (rdi, rsi, rdx):
    Sizes are (unsigned long, size_t, unsigned long)
    rax must be 10 
    """
    
    # Set the registers
    args = [['rdi',addr],['rsi', size],['rdx',prot], ['rax',10]]
    perms = permutations(args)
    for perm in perms:
        chain = pop_multiple(perm, constraint)
        if( chain ):
            break
                
    if( not chain ):
        print("DEBUG FAILED TO POP REGISTERS ! ")
        return []
    
    # Syscall 
    syscalls = search.int80(constraint)
    if( not syscalls ):
        print("DEBUG SUCCESS BUT MISSING SYSCALL")
    else:
        chain.append(syscalls[0])
        print("DEBUG SUCCESS !!")
    return chain
        
